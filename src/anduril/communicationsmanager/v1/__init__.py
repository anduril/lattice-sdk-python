# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: anduril/communicationsmanager/v1/blobs.pub.proto, anduril/communicationsmanager/v1/common.pub.proto, anduril/communicationsmanager/v1/communications_manager_api.pub.proto, anduril/communicationsmanager/v1/cross_domain.pub.proto, anduril/communicationsmanager/v1/entity.pub.proto, anduril/communicationsmanager/v1/integration.pub.proto
# plugin: python-betterproto
# This file has been @generated
import warnings
from dataclasses import dataclass
from datetime import datetime
from typing import (
    TYPE_CHECKING,
    AsyncIterator,
    Dict,
    List,
    Optional,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from ...blobs import v1 as __blobs_v1__
from ...entitymanager import v1 as __entitymanager_v1__


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class EventType(betterproto.Enum):
    """The type of distribution rule event."""

    EVENT_TYPE_INVALID = 0
    EVENT_TYPE_CREATED = 1
    """Rule was created."""

    EVENT_TYPE_UPDATE = 2
    """Rule was updated."""

    EVENT_TYPE_DELETED = 3
    """Rule was deleted."""

    EVENT_TYPE_PREEXISTING = 4
    """Rule already existed, but sent on a new stream connection."""


class IntegrationHealthStatus(betterproto.Enum):
    INTEGRATION_HEALTH_STATUS_INVALID = 0
    INTEGRATION_HEALTH_STATUS_UNKNOWN = 1
    INTEGRATION_HEALTH_STATUS_HEALTHY = 2
    INTEGRATION_HEALTH_STATUS_UNHEALTHY = 3


class RuleType(betterproto.Enum):
    RULE_TYPE_INVALID = 0
    RULE_TYPE_ENTITY = 1
    RULE_TYPE_BLOB = 2
    RULE_TYPE_INTEGRATION = 3


@dataclass(eq=False, repr=False)
class BlobsIntegrationDetails(betterproto.Message):
    data_types: List[str] = betterproto.string_field(1)
    """data types registered to the blobs integration."""


@dataclass(eq=False, repr=False)
class BlobIntegrationRuleDetails(betterproto.Message):
    """Message to contain blob integration rules"""

    filters: List["__blobs_v1__.Statement"] = betterproto.message_field(1)
    """The filter to be applied to the integration"""


@dataclass(eq=False, repr=False)
class RegisteredCds(betterproto.Message):
    host_id: str = betterproto.string_field(1)
    """Flux hexadecimal host id, i.e. '5a'."""

    cds_name: str = betterproto.string_field(2)
    """
    identifier of the CDS to apply the rule to. A single Flux host may have
    multiple CDS services.
    """


@dataclass(eq=False, repr=False)
class CdsDestination(betterproto.Message):
    registered_cds: "RegisteredCds" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class EntityIntegrationDetails(betterproto.Message):
    vendors: List["EntityDataVendor"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class EntityDataVendor(betterproto.Message):
    vendor_name: str = betterproto.string_field(1)
    data_type: List[str] = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class EntityIntegrationRuleDetails(betterproto.Message):
    """Message to contain entity integration rules"""

    filter: "__entitymanager_v1__.Statement" = betterproto.message_field(1)
    """The filter to be applied to the integration"""


@dataclass(eq=False, repr=False)
class DistributionRuleEvent(betterproto.Message):
    """Event representing a type of distribution rule change."""

    event_type: "EventType" = betterproto.enum_field(1)
    """The type of distribution rule event."""

    time: datetime = betterproto.message_field(2)
    distribution_rule: "DistributionRule" = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class RuleEvent(betterproto.Message):
    event_type: "EventType" = betterproto.enum_field(1)
    time: datetime = betterproto.message_field(2)
    rule: "Rule" = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class Rule(betterproto.Message):
    rule_id: str = betterproto.string_field(1)
    """
    Uniquely identifies a rule across hosts. If unset, the operation is treated
    as a creation operation by the implementing service.
    """

    version_num: int = betterproto.int64_field(2)
    """The version of this rule."""

    enabled: bool = betterproto.bool_field(3)
    """Whether or not this rule is enabled."""

    name: str = betterproto.string_field(4)
    """Human readable name associated with the rule."""

    distribution_rule: "DistributionRule" = betterproto.message_field(5, group="type")
    integration_rule: "IntegrationRule" = betterproto.message_field(6, group="type")
    cross_domain_rule: "CrossDomainRule" = betterproto.message_field(9, group="type")
    last_modified_by_user: str = betterproto.string_field(7)
    """Email of the user who last modified the rule."""

    last_modified_time_unix_epoch_ms: int = betterproto.int64_field(8)
    """
    Unix epoch timestamp in milliseconds of when the rule was last modified.
    """


@dataclass(eq=False, repr=False)
class IntegrationRule(betterproto.Message):
    integration_name: str = betterproto.string_field(1)
    """Uniquely identifies an integration on a node."""

    host_id: str = betterproto.string_field(2)
    """Producer hostId, equivalent to the rule's source."""

    entity_integration_rule_details: "EntityIntegrationRuleDetails" = (
        betterproto.message_field(3, group="details")
    )
    blob_integration_rule_details: "BlobDistributionRuleDetails" = (
        betterproto.message_field(4, group="details")
    )


@dataclass(eq=False, repr=False)
class DistributionRule(betterproto.Message):
    """
    Distribution rules are conjunctive (AND) when applied at the producer. This
    implies that given a primitive datum, if the datum satisfies a producer
    rule AND a consumer rule, it will be broadcast to the network.
    """

    rule_id: str = betterproto.string_field(1)
    """
    Uniquely identifies a rule across hosts. If unset, the operation is treated
    as a creation operation by the implementing service.
    """

    version: str = betterproto.string_field(2)
    """Deprecated: use version_num instead."""

    enabled: bool = betterproto.bool_field(3)
    """Whether or not this rule is enabled."""

    source: "Source" = betterproto.message_field(4)
    """Deprecated: use sources instead."""

    sources: List["Source"] = betterproto.message_field(8)
    """
    Used by consumer nodes to identify the source of the data to which they are
    subscribing. In the case of an 'all' source, only a single entry should be
    present.
    """

    destination: "Destination" = betterproto.message_field(5)
    """
    Used by producers to direct publish traffic. If unset, publish for this
    rule may be directed to all consumers.
    """

    entity_details: "EntityDistributionRuleDetails" = betterproto.message_field(
        6, group="details"
    )
    """
    Provides the fine-grained details controlling how entities are distributed.
    """

    blob_details: "BlobDistributionRuleDetails" = betterproto.message_field(
        13, group="details"
    )
    """
    Provides the fine-grained detials controlling how blobs are distributed.
    """

    priority: int = betterproto.uint32_field(7)
    """
    Determines the priority with which messages passing this rule are sent.
    Valid values are in the range of [0, 7]. 0 is the lowest and 7 is the
    highest priority.
    """

    description: str = betterproto.string_field(9)
    """Human readable description describing the DistributionRule."""

    name: str = betterproto.string_field(10)
    """Human readable name associated with the rule."""

    version_num: int = betterproto.int64_field(11)
    """The version of this distribution rule."""

    source_destination_directional_control: "SourceDestinationDirectionalControl" = (
        betterproto.message_field(12)
    )
    """
    Contains the definition for either an inbound rule []source -> destination
    relationship or an outbound rule source -> []destinations relationship.
    This will define the rule mechanism, where outbound rules are a deny-list
    and inbound rules are an allow-list.
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("version"):
            warnings.warn("DistributionRule.version is deprecated", DeprecationWarning)
        if self.is_set("source"):
            warnings.warn("DistributionRule.source is deprecated", DeprecationWarning)
        if self.is_set("sources"):
            warnings.warn("DistributionRule.sources is deprecated", DeprecationWarning)
        if self.is_set("destination"):
            warnings.warn(
                "DistributionRule.destination is deprecated", DeprecationWarning
            )


@dataclass(eq=False, repr=False)
class SourceDestinationDirectionalControl(betterproto.Message):
    inbound_rule_source_destination: "InboundRuleSourceDestination" = (
        betterproto.message_field(1, group="source_destination")
    )
    outbound_rule_source_destination: "OutboundRuleSourceDestination" = (
        betterproto.message_field(2, group="source_destination")
    )


@dataclass(eq=False, repr=False)
class OutboundRuleSourceDestination(betterproto.Message):
    """
    Many destinations to one source. The source will block data from being sent
    to the destinations when matched by a filter statement. Rule is owned by
    the source.
    """

    source: "Source" = betterproto.message_field(1)
    destinations: List["Destination"] = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class InboundRuleSourceDestination(betterproto.Message):
    """
    Many sources to one Destination. The destination will request data from the
    sources when matched by a filter statement. Rule is owned by the
    destination.
    """

    sources: List["Source"] = betterproto.message_field(1)
    destination: "Destination" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class Source(betterproto.Message):
    """A source from which primitive data are routed."""

    asset_id: str = betterproto.string_field(1, group="source")
    """The source is a particular asset ID."""

    all: bool = betterproto.bool_field(2, group="source")
    """
    The source is all sources. This selection is only used for inbound rules.
    """

    host_id: str = betterproto.string_field(3, group="source")
    """The source is a particular host ID."""

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("asset_id"):
            warnings.warn("Source.asset_id is deprecated", DeprecationWarning)


@dataclass(eq=False, repr=False)
class Destination(betterproto.Message):
    """A destination to which data are routed."""

    asset_id: str = betterproto.string_field(1, group="destination")
    """The destination is a particular asset ID."""

    host_id: str = betterproto.string_field(2, group="destination")
    """The destination is a particular host ID."""

    all: bool = betterproto.bool_field(3, group="destination")
    """
    The destination is all destinations. This selection is only used for
    outbound rules.
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("asset_id"):
            warnings.warn("Destination.asset_id is deprecated", DeprecationWarning)


@dataclass(eq=False, repr=False)
class EntityDistributionRuleDetails(betterproto.Message):
    """
    Message to contain additional business logic for entities. Entity_Filter
    and Dynamic Statement are ANDed together when both are present.
    """

    entity_filter: "__entitymanager_v1__.Statement" = betterproto.message_field(1)
    """
    Controls the filtering which should be applied in the compliant service. TO
    BE DEPRECATED, use entity_filter_selection
    """

    static_statement: "__entitymanager_v1__.Statement" = betterproto.message_field(
        2, group="entity_filter_selection"
    )
    """
    Controls the filtering which should be applied in the compliant service.
    """

    dynamic_statement: "__entitymanager_v1__.DynamicStatement" = (
        betterproto.message_field(3, group="entity_filter_selection")
    )
    """Used for matching location details."""


@dataclass(eq=False, repr=False)
class BlobDistributionRuleDetails(betterproto.Message):
    blob_filter: "__blobs_v1__.Statement" = betterproto.message_field(1)
    blob_filters: List["__blobs_v1__.Statement"] = betterproto.message_field(2)
    """
    Controls blob filtering using disjoint matching, meaning only 1 statement
    needs to match.
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("blob_filter"):
            warnings.warn(
                "BlobDistributionRuleDetails.blob_filter is deprecated",
                DeprecationWarning,
            )


@dataclass(eq=False, repr=False)
class CommunicationsManagerError(betterproto.Message):
    """CommunicationsManagerError message contents."""

    message: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class CrossDomainRule(betterproto.Message):
    """
    Rule to apply to Cross Domain, will function as an inbound filter which
    allows matching entities to pass through.
    """

    entity_details: "EntityDistributionRuleDetails" = betterproto.message_field(
        1, group="details"
    )
    cds_destination: "CdsDestination" = betterproto.message_field(2)
    """Destination CDS to apply the rule to."""


@dataclass(eq=False, repr=False)
class RegisterIntegrationRequest(betterproto.Message):
    integration_name: str = betterproto.string_field(1)
    """
    Identifying name for the integration. This must be unique on the local
    node.
    """

    details: "IntegrationDetails" = betterproto.message_field(2)
    """Specifies the registered data_types and health for the integration."""


@dataclass(eq=False, repr=False)
class RegisteredIntegration(betterproto.Message):
    integration_name: str = betterproto.string_field(1)
    """
    Identifies the integration. Must be unique for the node, meaning
    integration_name + node_id is globally unique.
    """

    node_id: str = betterproto.string_field(2)
    """The id of the node that owns this integration."""

    version_num: int = betterproto.int64_field(4)
    """
    The version of this registered integration. Set internally by CM, not to be
    used externally.
    """

    integration_details: "IntegrationDetails" = betterproto.message_field(3)
    """Specifies the registered data_types and health for the integration."""

    health_state: "IntegrationHealthState" = betterproto.message_field(5)
    """Health of this integration"""


@dataclass(eq=False, repr=False)
class IntegrationDetails(betterproto.Message):
    entity_details: "EntityIntegrationDetails" = betterproto.message_field(1)
    blob_details: "BlobsIntegrationDetails" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class DeregisterIntegrationRequest(betterproto.Message):
    integration_name: str = betterproto.string_field(1)
    """
    Identifier for the integration. The integration_name + node_id is globally
    unique.
    """

    node_id: str = betterproto.string_field(2)
    """
    Unique identifier for the node that the integration is registered under.
    """


@dataclass(eq=False, repr=False)
class DeregisterIntegrationResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GetIntegrationsRequest(betterproto.Message):
    nodes: List[str] = betterproto.string_field(1)
    """
    String of node ids. If no nodes are specified, integrations for all nodes
    are returned.
    """


@dataclass(eq=False, repr=False)
class GetIntegrationsResponse(betterproto.Message):
    integration: List["RegisteredIntegration"] = betterproto.message_field(1)
    """Contains the registered integration data"""


@dataclass(eq=False, repr=False)
class AllNodes(betterproto.Message):
    """
    Return all integrations registered with the system, regardless of which
    node they are registered with.
    """

    pass


@dataclass(eq=False, repr=False)
class LocalNode(betterproto.Message):
    """
    Return all integrations registered to the local communications-manager
    instance.
    """

    pass


@dataclass(eq=False, repr=False)
class StreamIntegrationsRequest(betterproto.Message):
    all_nodes: "AllNodes" = betterproto.message_field(1, group="owner_filter")
    local_node: "LocalNode" = betterproto.message_field(2, group="owner_filter")
    preexisting_only: bool = betterproto.bool_field(3)
    """
    Close the stream after sending all currently existing integrations. Set
    this to false to have a long-lived stream.
    """


@dataclass(eq=False, repr=False)
class IntegrationEvent(betterproto.Message):
    event_type: "EventType" = betterproto.enum_field(1)
    time: datetime = betterproto.message_field(2)
    integration: "RegisteredIntegration" = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class StreamIntegrationsResponse(betterproto.Message):
    integration_event: "IntegrationEvent" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class IntegrationHealthUpdateRequest(betterproto.Message):
    """IntegrationHealth"""

    integration_name: str = betterproto.string_field(1)
    """name of the integration reporting its health"""

    health_state: "IntegrationHealthState" = betterproto.message_field(2)
    """the health of the integration"""


@dataclass(eq=False, repr=False)
class IntegrationHealthUpdateResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class IntegrationHealthState(betterproto.Message):
    health_status: "IntegrationHealthStatus" = betterproto.enum_field(1)
    description: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class PutRuleRequest(betterproto.Message):
    """A request to put a rule on this distribution manager."""

    rule: "Rule" = betterproto.message_field(2)
    distribution_rule: "DistributionRule" = betterproto.message_field(1)
    """To be DEPRECATED. Use `Rule`"""


@dataclass(eq=False, repr=False)
class PutRuleResponse(betterproto.Message):
    """A response indicating success or failure of the PutRuleRequest."""

    rule: "Rule" = betterproto.message_field(3)
    """
    The current version of the rule after attempting to Put a rule. On success,
    version_num is incremented by 1. On conflict the current, nonupdated
    version is returned and containing the current version_num.
    """

    error: "CommunicationsManagerError" = betterproto.message_field(2)
    """
    Error message returned in the event of an error such as a Proto-KV
    conflict.
    """

    distribution_rule: "DistributionRule" = betterproto.message_field(1)
    """To be DEPRECATED. Use `Rule`"""


@dataclass(eq=False, repr=False)
class StreamRulesRequest(betterproto.Message):
    """A request to stream rules from this node's distribution manager."""

    rule_type: List["RuleType"] = betterproto.enum_field(1)
    preexisting_only: bool = betterproto.bool_field(2)
    """
    Stream preexisting rules only and close the stream once all preexisting
    rules have been provided.
    """


@dataclass(eq=False, repr=False)
class StreamRulesResponse(betterproto.Message):
    """
    A response stream will be fed all matching pre-existing rules first, then
    receive any ongoing events.
    """

    rule_event: "RuleEvent" = betterproto.message_field(2)
    distribution_rule_event: "DistributionRuleEvent" = betterproto.message_field(1)
    """To be DEPRECATED. Use `RuleEvent`"""


@dataclass(eq=False, repr=False)
class DeleteRuleRequest(betterproto.Message):
    """A request to delete a rule on this distribution manager."""

    rule: "Rule" = betterproto.message_field(2)
    distribution_rule: "DistributionRule" = betterproto.message_field(1)
    """To be DEPRECATED. Use `Rule`"""


@dataclass(eq=False, repr=False)
class DeleteRuleResponse(betterproto.Message):
    """A response indicating success or failure of the DeleteRuleRequest."""

    rule: "Rule" = betterproto.message_field(3)
    """
    The current version of the rule after attempting to delete a rule. On
    success, distribution_rule is null. On failure, the rule returned is the
    conflicted version.
    """

    error: "CommunicationsManagerError" = betterproto.message_field(2)
    """
    Error message returned in the event of an error such as a Proto-KV
    conflict.
    """

    distribution_rule: "DistributionRule" = betterproto.message_field(1)
    """To be DEPRECATED. Use `Rule`"""


class CommunicationsManagerApiStub(betterproto.ServiceStub):
    async def put_rule(
        self,
        put_rule_request: "PutRuleRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "PutRuleResponse":
        return await self._unary_unary(
            "/anduril.communicationsmanager.v1.CommunicationsManagerAPI/PutRule",
            put_rule_request,
            PutRuleResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def stream_rules(
        self,
        stream_rules_request: "StreamRulesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["StreamRulesResponse"]:
        async for response in self._unary_stream(
            "/anduril.communicationsmanager.v1.CommunicationsManagerAPI/StreamRules",
            stream_rules_request,
            StreamRulesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delete_rule(
        self,
        delete_rule_request: "DeleteRuleRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeleteRuleResponse":
        return await self._unary_unary(
            "/anduril.communicationsmanager.v1.CommunicationsManagerAPI/DeleteRule",
            delete_rule_request,
            DeleteRuleResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def stream_integrations(
        self,
        stream_integrations_request: "StreamIntegrationsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["StreamIntegrationsResponse"]:
        async for response in self._unary_stream(
            "/anduril.communicationsmanager.v1.CommunicationsManagerAPI/StreamIntegrations",
            stream_integrations_request,
            StreamIntegrationsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_integrations(
        self,
        get_integrations_request: "GetIntegrationsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetIntegrationsResponse":
        return await self._unary_unary(
            "/anduril.communicationsmanager.v1.CommunicationsManagerAPI/GetIntegrations",
            get_integrations_request,
            GetIntegrationsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def integration_health_update(
        self,
        integration_health_update_request: "IntegrationHealthUpdateRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "IntegrationHealthUpdateResponse":
        return await self._unary_unary(
            "/anduril.communicationsmanager.v1.CommunicationsManagerAPI/IntegrationHealthUpdate",
            integration_health_update_request,
            IntegrationHealthUpdateResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class CommunicationsManagerApiBase(ServiceBase):

    async def put_rule(self, put_rule_request: "PutRuleRequest") -> "PutRuleResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def stream_rules(
        self, stream_rules_request: "StreamRulesRequest"
    ) -> AsyncIterator["StreamRulesResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield StreamRulesResponse()

    async def delete_rule(
        self, delete_rule_request: "DeleteRuleRequest"
    ) -> "DeleteRuleResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def stream_integrations(
        self, stream_integrations_request: "StreamIntegrationsRequest"
    ) -> AsyncIterator["StreamIntegrationsResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield StreamIntegrationsResponse()

    async def get_integrations(
        self, get_integrations_request: "GetIntegrationsRequest"
    ) -> "GetIntegrationsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def integration_health_update(
        self, integration_health_update_request: "IntegrationHealthUpdateRequest"
    ) -> "IntegrationHealthUpdateResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_put_rule(
        self, stream: "grpclib.server.Stream[PutRuleRequest, PutRuleResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.put_rule(request)
        await stream.send_message(response)

    async def __rpc_stream_rules(
        self, stream: "grpclib.server.Stream[StreamRulesRequest, StreamRulesResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.stream_rules,
            stream,
            request,
        )

    async def __rpc_delete_rule(
        self, stream: "grpclib.server.Stream[DeleteRuleRequest, DeleteRuleResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete_rule(request)
        await stream.send_message(response)

    async def __rpc_stream_integrations(
        self,
        stream: "grpclib.server.Stream[StreamIntegrationsRequest, StreamIntegrationsResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.stream_integrations,
            stream,
            request,
        )

    async def __rpc_get_integrations(
        self,
        stream: "grpclib.server.Stream[GetIntegrationsRequest, GetIntegrationsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_integrations(request)
        await stream.send_message(response)

    async def __rpc_integration_health_update(
        self,
        stream: "grpclib.server.Stream[IntegrationHealthUpdateRequest, IntegrationHealthUpdateResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.integration_health_update(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/anduril.communicationsmanager.v1.CommunicationsManagerAPI/PutRule": grpclib.const.Handler(
                self.__rpc_put_rule,
                grpclib.const.Cardinality.UNARY_UNARY,
                PutRuleRequest,
                PutRuleResponse,
            ),
            "/anduril.communicationsmanager.v1.CommunicationsManagerAPI/StreamRules": grpclib.const.Handler(
                self.__rpc_stream_rules,
                grpclib.const.Cardinality.UNARY_STREAM,
                StreamRulesRequest,
                StreamRulesResponse,
            ),
            "/anduril.communicationsmanager.v1.CommunicationsManagerAPI/DeleteRule": grpclib.const.Handler(
                self.__rpc_delete_rule,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeleteRuleRequest,
                DeleteRuleResponse,
            ),
            "/anduril.communicationsmanager.v1.CommunicationsManagerAPI/StreamIntegrations": grpclib.const.Handler(
                self.__rpc_stream_integrations,
                grpclib.const.Cardinality.UNARY_STREAM,
                StreamIntegrationsRequest,
                StreamIntegrationsResponse,
            ),
            "/anduril.communicationsmanager.v1.CommunicationsManagerAPI/GetIntegrations": grpclib.const.Handler(
                self.__rpc_get_integrations,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetIntegrationsRequest,
                GetIntegrationsResponse,
            ),
            "/anduril.communicationsmanager.v1.CommunicationsManagerAPI/IntegrationHealthUpdate": grpclib.const.Handler(
                self.__rpc_integration_health_update,
                grpclib.const.Cardinality.UNARY_UNARY,
                IntegrationHealthUpdateRequest,
                IntegrationHealthUpdateResponse,
            ),
        }
