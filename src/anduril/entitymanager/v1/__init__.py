# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: anduril/entitymanager/v1/classification.pub.proto, anduril/entitymanager/v1/contact_details.pub.proto, anduril/entitymanager/v1/correlations.pub.proto, anduril/entitymanager/v1/dimensions.pub.proto, anduril/entitymanager/v1/entity.pub.proto, anduril/entitymanager/v1/entity_manager_api.pub.proto, anduril/entitymanager/v1/filter.pub.proto, anduril/entitymanager/v1/filter_dynamic.pub.proto, anduril/entitymanager/v1/geoentity.pub.proto, anduril/entitymanager/v1/group.pub.proto, anduril/entitymanager/v1/health_status.pub.proto, anduril/entitymanager/v1/location.pub.proto, anduril/entitymanager/v1/media.pub.proto, anduril/entitymanager/v1/notification.pub.proto, anduril/entitymanager/v1/ontology.pub.proto, anduril/entitymanager/v1/options.pub.proto, anduril/entitymanager/v1/payloads.pub.proto, anduril/entitymanager/v1/power.pub.proto, anduril/entitymanager/v1/prototype.pub.proto, anduril/entitymanager/v1/rate_limit.pub.proto, anduril/entitymanager/v1/relationship.pub.proto, anduril/entitymanager/v1/route_details.pub.proto, anduril/entitymanager/v1/schedule.pub.proto, anduril/entitymanager/v1/sensors.pub.proto, anduril/entitymanager/v1/signal.pub.proto, anduril/entitymanager/v1/supplies.pub.proto, anduril/entitymanager/v1/target_priority.pub.proto, anduril/entitymanager/v1/transponder_codes.pub.proto, anduril/entitymanager/v1/types.pub.proto
# plugin: python-betterproto
# This file has been @generated
import warnings
from dataclasses import dataclass
from datetime import datetime
from typing import (
    TYPE_CHECKING,
    AsyncIterable,
    AsyncIterator,
    Dict,
    Iterable,
    List,
    Optional,
    Union,
)

import betterproto
import betterproto.lib.google.protobuf as betterproto_lib_google_protobuf
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from ... import type as __type__
from ...ontology import v1 as __ontology_v1__
from ...tasks import v2 as __tasks_v2__


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class GeoType(betterproto.Enum):
    """The type of geo entity."""

    GEO_TYPE_INVALID = 0
    GEO_TYPE_GENERAL = 1
    GEO_TYPE_HAZARD = 2
    GEO_TYPE_EMERGENCY = 3
    GEO_TYPE_FSCM = 4
    """Fire support coordination measure"""

    GEO_TYPE_ENGAGEMENT_ZONE = 5
    """
    Engagement zones allow for engaging an entity if it comes within the zone
    of another entity.
    """

    GEO_TYPE_CONTROL_AREA = 6
    GEO_TYPE_BULLSEYE = 7
    GEO_TYPE_ACM = 8
    """Airspace Coordinating Measure"""

    GEO_TYPE_MCM = 9
    """Maneuver Control Measure"""


class EmergencyType(betterproto.Enum):
    """Type of an emergency."""

    EMERGENCY_TYPE_INVALID = 0
    EMERGENCY_TYPE_DOWN_AIRCRAFT = 1
    EMERGENCY_TYPE_MAN_IN_WATER = 2
    EMERGENCY_TYPE_DITCHING = 3
    EMERGENCY_TYPE_BAILOUT = 4
    EMERGENCY_TYPE_DISTRESSED_VEHICLE = 5
    EMERGENCY_TYPE_GROUND_INCIDENT = 6
    EMERGENCY_TYPE_MEDICAL = 7
    EMERGENCY_TYPE_ISOLATED_PERSON = 8


class ControlAreaType(betterproto.Enum):
    CONTROL_AREA_TYPE_INVALID = 0
    CONTROL_AREA_TYPE_KEEP_IN_ZONE = 1
    CONTROL_AREA_TYPE_KEEP_OUT_ZONE = 2
    CONTROL_AREA_TYPE_DITCH_ZONE = 3
    """
    Zone for an autonomous asset to nose-dive into when its assignment has been
    concluded
    """

    CONTROL_AREA_TYPE_OBSERVATION_EXCLUSION = 4
    """Areas where we do not process radar detections"""

    CONTROL_AREA_TYPE_OBSERVATION_INCLUSION = 5
    """Areas where we process radar detections exclusively"""

    CONTROL_AREA_TYPE_OBSERVATION_PRIORITY = 6
    """Areas where we elevate interrogation priority"""


class FscmDetailType(betterproto.Enum):
    FSCM_DETAIL_TYPE_INVALID = 0
    FSCM_DETAIL_TYPE_DEAD_SPACE_AREA = 1
    FSCM_DETAIL_TYPE_NO_FIRE_AREA = 2
    FSCM_DETAIL_TYPE_FREE_FIRE_AREA = 3
    FSCM_DETAIL_TYPE_RESTRICTIVE_FIRE_AREA = 4
    FSCM_DETAIL_TYPE_SAFE_FIRE_AREA = 5
    FSCM_DETAIL_TYPE_AIRSPACE_COORDINATION_AREA = 6
    FSCM_DETAIL_TYPE_FORWARD_EDGE_OF_THE_BATTLE_AREA = 7
    FSCM_DETAIL_TYPE_FIRE_SUPPORT_AREA = 8
    FSCM_DETAIL_TYPE_PATROL_RECONNAISSANCE = 9
    FSCM_DETAIL_TYPE_ZONE_OF_RESPONSIBILITY = 10
    FSCM_DETAIL_TYPE_PRIORITY_CALL_FOR_FIRE_ZONE = 11
    FSCM_DETAIL_TYPE_CENSORED_ZONE = 12
    FSCM_DETAIL_TYPE_ZONE_OF_ACTION = 13
    FSCM_DETAIL_TYPE_CRITICAL_FRIENDLY_ZONE = 14
    FSCM_DETAIL_TYPE_PLATOON_AREA_HAZARD = 15
    FSCM_DETAIL_TYPE_TARGET_AREA_HAZARD = 16
    FSCM_DETAIL_TYPE_RESTRICTED_OPERATIONS_ZONE = 17
    FSCM_DETAIL_TYPE_AIR_CORRIDOR = 18
    FSCM_DETAIL_TYPE_RESTRICTIVE_FIRE_LINE = 19
    FSCM_DETAIL_TYPE_COORDINATED_FIRE_LINE_NO_FIRE_LINE = 20
    FSCM_DETAIL_TYPE_BOUNDARY_LINE = 21
    FSCM_DETAIL_TYPE_FORWARD_LINE = 22
    FSCM_DETAIL_TYPE_FIRE_SUPPORT_LINE = 23
    FSCM_DETAIL_TYPE_LINE_OF_DEPARTURE = 24
    FSCM_DETAIL_TYPE_LINE_OF_CONTACT = 25
    FSCM_DETAIL_TYPE_LINE_OF_DEPARTURE_LINE_OF_CONTACT = 26
    FSCM_DETAIL_TYPE_ZONE_OF_FIRE = 27


class AcmDetailType(betterproto.Enum):
    ACM_DETAIL_TYPE_INVALID = 0
    ACM_DETAIL_TYPE_AIR_CORRIDOR = 1
    ACM_DETAIL_TYPE_MINIMUM_RISK_ROUTE = 2
    ACM_DETAIL_TYPE_TEMPORARY_MINIMUM_RISK_ROUTE = 3
    ACM_DETAIL_TYPE_TRANSIT_ROUTE = 4
    ACM_DETAIL_TYPE_LOW_LEVEL_TRANSIT_ROUTE = 5
    ACM_DETAIL_TYPE_SPECIAL_CORRIDOR = 6
    ACM_DETAIL_TYPE_STANDARD_USE_ARMY_AIRCRAFT_FLIGHT_ROUTE = 7
    ACM_DETAIL_TYPE_RESTRICTED_OPERATIONS_ZONE = 8
    ACM_DETAIL_TYPE_AIR_TO_AIR_REFUELING_AREA = 9
    ACM_DETAIL_TYPE_AIRBORNE_COMMAND_AND_CONTROL_AREA = 10
    ACM_DETAIL_TYPE_AIRBORNE_EARLY_WARNING_AREA = 11
    ACM_DETAIL_TYPE_CLOSE_AIR_SUPPORT_AREA = 12
    ACM_DETAIL_TYPE_COMBAT_AIR_PATROL = 13
    ACM_DETAIL_TYPE_DROP_ZONE = 14
    ACM_DETAIL_TYPE_ELECTRONIC_COMBAT = 15
    ACM_DETAIL_TYPE_LANDING_ZONE = 16
    ACM_DETAIL_TYPE_PICKUP_ZONE = 17
    ACM_DETAIL_TYPE_RECONNAISSANCE_AREA = 18
    ACM_DETAIL_TYPE_SPECIAL_OPERATIONS_FORCE_AREA = 19
    ACM_DETAIL_TYPE_SURFACE_TO_SURFACE_MISSILE_SYSTEM = 20
    ACM_DETAIL_TYPE_SURFACE_TO_SURFACE_MUNITIONS = 21
    ACM_DETAIL_TYPE_UNMANNED_AIRCRAFT_AREA = 22
    ACM_DETAIL_TYPE_COORDINATING_ALTITUDE = 23
    ACM_DETAIL_TYPE_COORDINATION_LEVEL = 24
    ACM_DETAIL_TYPE_HIGH_DENSITY_AIRSPACE_CONTROL_ZONE = 25
    ACM_DETAIL_TYPE_NO_FLY_AREA = 26
    ACM_DETAIL_TYPE_TRANSIT_CORRIDOR = 27
    ACM_DETAIL_TYPE_RETURN_TO_FORCE = 28


class AmmoRestrictionType(betterproto.Enum):
    AMMO_RESTRICTION_TYPE_INVALID = 0
    AMMO_RESTRICTION_TYPE_HIGH_EXPLOSIVE_MUNITIONS = 1
    AMMO_RESTRICTION_TYPE_IMPROVED_CONVENTIONAL_MUNITIONS = 2
    AMMO_RESTRICTION_TYPE_CHEMICAL_MUNITIONS = 3
    AMMO_RESTRICTION_TYPE_NUCLEAR_MUNITIONS = 4
    AMMO_RESTRICTION_TYPE_WHITE_PHOSPHORUS_MUNITIONS = 5
    AMMO_RESTRICTION_TYPE_ILLUMINATION_MUNITIONS = 6
    AMMO_RESTRICTION_TYPE_TERMINAL_HOMING_MUNITIONS = 7
    AMMO_RESTRICTION_TYPE_FASCAM_MUNITIONS = 8
    AMMO_RESTRICTION_TYPE_SMOKE_MUNITIONS = 9
    AMMO_RESTRICTION_TYPE_ALL_MUNITIONS = 10


class RestrictiveMeasureType(betterproto.Enum):
    RESTRICTIVE_MEASURE_TYPE_INVALID = 0
    RESTRICTIVE_MEASURE_TYPE_STAY_INSIDE_AREA = 1
    RESTRICTIVE_MEASURE_TYPE_STAY_OUTSIDE_AREA = 2
    RESTRICTIVE_MEASURE_TYPE_STAY_ABOVE_AREA = 3
    RESTRICTIVE_MEASURE_TYPE_STAY_BELOW_AREA = 4
    RESTRICTIVE_MEASURE_TYPE_STAY_NORTH_OF_LINE = 5
    RESTRICTIVE_MEASURE_TYPE_STAY_EAST_OF_LINE = 6
    RESTRICTIVE_MEASURE_TYPE_STAY_SOUTH_OF_LINE = 7
    RESTRICTIVE_MEASURE_TYPE_STAY_WEST_OF_LINE = 8


class McmDetailType(betterproto.Enum):
    MCM_DETAIL_TYPE_INVALID = 0
    MCM_DETAIL_TYPE_NAMED_AREA_OF_INTEREST = 1
    MCM_DETAIL_TYPE_TARGET_AREA_OF_INTEREST = 2


class Comparator(betterproto.Enum):
    """
    The Comparator specifies the set of supported comparison operations. It
    also provides the mapping information about which comparators are supported
    for which values. Services that wish to implement entity filters must
    provide validation functionality to strictly enforce these mappings.
    """

    COMPARATOR_INVALID = 0
    COMPARATOR_MATCH_ALL = 11
    """
    Comparators for: boolean, numeric, string, enum, position, timestamp,
    positions, and bounded shapes.
    """

    COMPARATOR_EQUALITY = 1
    """
    Comparators for: boolean, numeric, string, enum, position, and timestamp.
    """

    COMPARATOR_IN = 9
    COMPARATOR_LESS_THAN = 2
    """Comparators for: numeric, string, and timestamp."""

    COMPARATOR_GREATER_THAN = 3
    COMPARATOR_LESS_THAN_EQUAL_TO = 4
    COMPARATOR_GREATER_THAN_EQUAL_TO = 5
    COMPARATOR_WITHIN = 6
    """Comparators for: positions and bounded shapes."""

    COMPARATOR_EXISTS = 7
    """
    Comparators for: existential checks. TRUE if path to field exists (parent
    message is present), and either:   1. the field is a primitive: all values
    including default pass check.   2. the field is a message and set/present.
    3. the field is repeated or map with size > 0. FALSE unless path exists and
    one of the above 3 conditions is met
    """

    COMPARATOR_CASE_INSENSITIVE_EQUALITY = 8
    """Comparator for string type only."""

    COMPARATOR_CASE_INSENSITIVE_EQUALITY_IN = 10
    COMPARATOR_RANGE_CLOSED = 12
    """
    Comparators for range types only. Closed (inclusive endpoints) [a, b]
    """


class ListComparator(betterproto.Enum):
    """
    The ListComparator determines how to compose statement evaluations for
    members of a list. For example, if ANY_OF is specified, the ListOperation
    in which the ListComparator is embedded will return TRUE if any of the
    values in the list returns true for the ListOperation's child statement.
    """

    LIST_COMPARATOR_INVALID = 0
    LIST_COMPARATOR_ANY_OF = 1


class ClassificationLevels(betterproto.Enum):
    """An enumeration of security classification levels."""

    CLASSIFICATION_LEVELS_INVALID = 0
    CLASSIFICATION_LEVELS_UNCLASSIFIED = 1
    CLASSIFICATION_LEVELS_CONTROLLED_UNCLASSIFIED = 2
    CLASSIFICATION_LEVELS_CONFIDENTIAL = 3
    CLASSIFICATION_LEVELS_SECRET = 4
    CLASSIFICATION_LEVELS_TOP_SECRET = 5


class CorrelationStatus(betterproto.Enum):
    """The status of the correlation."""

    CORRELATION_STATUS_INVALID = 0
    CORRELATION_STATUS_MANUAL_INSPECTION = 1
    """
    potential correlation requested by manual inspection, not yet confirmed.
    """

    CORRELATION_STATUS_AUTO_SUGGESTED = 2
    """potential correlation suggested by system, not yet confirmed."""

    CORRELATION_STATUS_START_CORRELATE = 3
    """deprecated"""

    CORRELATION_STATUS_CONFIRMED = 4
    """correlation has been confirmed, treat non primary as hidden."""

    CORRELATION_STATUS_DENIED = 5
    """correlation was explicitly rejected, treat as non correlated."""


class ScoreInterpretation(betterproto.Enum):
    """The interpretation of the correlation score."""

    SCORE_INTERPRETATION_INVALID = 0
    SCORE_INTERPRETATION_UNLIKELY = 1
    """unlikely these are the same entity"""

    SCORE_INTERPRETATION_LIKELY = 2
    """likely these are the same entity"""

    SCORE_INTERPRETATION_VERY_LIKELY = 3
    """very likely these are the same entity"""


class ConnectionStatus(betterproto.Enum):
    """Enumeration of possible connection states."""

    CONNECTION_STATUS_INVALID = 0
    CONNECTION_STATUS_ONLINE = 1
    CONNECTION_STATUS_OFFLINE = 2


class HealthStatus(betterproto.Enum):
    """Enumeration of possible health states."""

    HEALTH_STATUS_INVALID = 0
    HEALTH_STATUS_HEALTHY = 1
    """Indicates that the component is operating as intended."""

    HEALTH_STATUS_WARN = 2
    """
    Indicates that the component is at risk of transitioning into a
    HEALTH_STATUS_FAIL state or that the component is operating in a degraded
    state.
    """

    HEALTH_STATUS_FAIL = 3
    """Indicates that the component is not functioning as intended."""

    HEALTH_STATUS_OFFLINE = 4
    """Indicates that the component is offline."""

    HEALTH_STATUS_NOT_READY = 5
    """
    Indicates that the component is not yet functioning, but it is
    transitioning into a HEALTH_STATUS_HEALTHY state. A component should only
    report this state temporarily.
    """


class MediaType(betterproto.Enum):
    MEDIA_TYPE_INVALID = 0
    MEDIA_TYPE_THUMBNAIL = 1
    MEDIA_TYPE_IMAGE = 2
    MEDIA_TYPE_VIDEO = 3
    MEDIA_TYPE_SLIPPY_TILES = 4


class AltIdType(betterproto.Enum):
    """The type of alternate id."""

    ALT_ID_TYPE_INVALID = 0
    ALT_ID_TYPE_TRACK_ID_2 = 1
    """an Anduril trackId_2"""

    ALT_ID_TYPE_TRACK_ID_1 = 12
    """an Anduril trackId_1"""

    ALT_ID_TYPE_SPI_ID = 2
    """an Anduril Sensor Point of Interest ID"""

    ALT_ID_TYPE_NITF_FILE_TITLE = 3
    """NITF file title"""

    ALT_ID_TYPE_TRACK_REPO_ALERT_ID = 4
    """Track repo alert ID"""

    ALT_ID_TYPE_ASSET_ID = 5
    """an Anduril AssetId"""

    ALT_ID_TYPE_LINK16_TRACK_NUMBER = 6
    """deprecated, do not use"""

    ALT_ID_TYPE_LINK16_JU = 7
    """
    a Link 16 track number. This will allow a link 16 asset (STN) or track
    (RefTN) to be identified.
    """

    ALT_ID_TYPE_NCCT_MESSAGE_ID = 8
    """an NCCT message ID"""

    ALT_ID_TYPE_CALLSIGN = 9
    """callsign for the entity. e.g. a TAK callsign or an aircraft callsign"""

    ALT_ID_TYPE_MMSI_ID = 10
    """
    the Maritime Mobile Service Identity for a maritime object (vessel,
    offshore installation, etc.)
    """

    ALT_ID_TYPE_VMF_URN = 11
    """A VMF URN that uniquely identifies the URN on the VMF network."""

    ALT_ID_TYPE_IMO_ID = 13
    """
    the International Maritime Organization number for identifying maritime
    objects (vessel, offshore installation, etc.)
    """

    ALT_ID_TYPE_VMF_TARGET_NUMBER = 14
    """
    A VMF target number that uniquely identifies the target on the VMF network
    """

    ALT_ID_TYPE_SERIAL_NUMBER = 15
    """
    A serial number that uniquely identifies the entity and is permanently
    associated with only one entity. This identifier is assigned by some
    authority and only ever identifies a single thing. Examples include a
    Vehicle Identification Number (VIN) or ship hull identification number
    (hull number). This is a generalized component and should not be used if a
    more specific registration type is already defined (i.e.,
    ALT_ID_TYPE_VMF_URN).
    """

    ALT_ID_TYPE_REGISTRATION_ID = 16
    """
    A registration identifier assigned by a local or national authority. This
    identifier is not permanently fixed to one specific entity and may be
    reassigned on change of ownership, destruction, or other conditions set
    forth by the authority. Examples include a vehicle license plate or
    aircraft tail number. This is a generalized component and should not be
    used if a more specific registration type is already defined (i.e.,
    ALT_ID_TYPE_IMO_ID).
    """

    ALT_ID_TYPE_IBS_GID = 17
    """Integrated Broadcast Service Common Message Format Global Identifier"""

    ALT_ID_TYPE_DODAAC = 18
    """
    Department of Defense Activity Address Code uniquely identifies a unit,
    activity, or organization with the DoDAAD. A single unit could have
    multiple DoDAACs
    """

    ALT_ID_TYPE_UIC = 19
    """
    Unit Identification Code uniquely identifies each US Department of Defense
    entity
    """

    ALT_ID_TYPE_NORAD_CAT_ID = 20
    """
    A NORAD Satellite Catalog Number, a 9-digit number uniquely representing
    orbital objects around Earth. This is the standard ID used for satellites
    by the DOD. Note that there is ongoing work to replace the 9-digit number
    with a 9-digit alphanumeric sequence to accommodate ever-increasing numbers
    of satellites (and space debris). Treat the accompanied ID field as
    alphanumeric instead of strictly numeric.
    """


class Template(betterproto.Enum):
    """
    Set of possible templates used when creating an entity. This impacts
    minimum required component sets and can be used by edge systems that need
    to distinguish.
    """

    TEMPLATE_INVALID = 0
    TEMPLATE_TRACK = 1
    """additional track required components:   * location   * mil_view"""

    TEMPLATE_SENSOR_POINT_OF_INTEREST = 2
    """
    additional SPI required components:   * location   * mil_view   *
    produced_by
    """

    TEMPLATE_ASSET = 3
    """
    additional asset required components:   * location   * mil_view   *
    ontology
    """

    TEMPLATE_GEO = 4
    """additional geo required components:   * geo_shape   * geo_details"""

    TEMPLATE_SIGNAL_OF_INTEREST = 5
    """
    additional SOI required components:   * signal   * location field should be
    populated if there is a fix.   * mil_view   * ontology
    """


class Source(betterproto.Enum):
    """The source (provenance) of data."""

    SOURCE_INVALID = 0
    SOURCE_ANDURIL = 1
    SOURCE_LINK_16 = 2
    SOURCE_VMF = 3
    SOURCE_ADSB = 4
    SOURCE_CURSOR_ON_TARGET = 5
    SOURCE_MAXAR = 6
    SOURCE_MARTAC = 7
    SOURCE_SAILDRONE = 8
    SOURCE_HE_360 = 9
    SOURCE_OFX = 10
    SOURCE_BAS_T = 11
    SOURCE_KINETICA = 12
    SOURCE_USER = 13
    SOURCE_NCCT = 14
    SOURCE_AIS = 15
    SOURCE_KLV = 16
    SOURCE_NITF = 17
    SOURCE_TAK = 18
    SOURCE_SPIRE_AIS = 19
    SOURCE_SEFI = 20
    SOURCE_ADSB_EXCHANGE = 21
    SOURCE_LIVE_UA_MAP = 22
    SOURCE_CRUCIBLE = 23
    SOURCE_IBS = 24
    SOURCE_ADVANA = 25
    SOURCE_THRESHER = 26
    SOURCE_SEATRACKS = 27
    SOURCE_TASS = 28
    SOURCE_SMART_SENSOR = 30
    SOURCE_STRIVEWORKS = 31
    SOURCE_L3H_THEIA = 32
    SOURCE_TALON_POWDERHORN = 33
    SOURCE_IDT_VIRTUAL_TWIN = 34
    SOURCE_MISSION_AUTONOMY = 35
    SOURCE_GCCS = 36
    SOURCE_FOUNDRY = 37
    SOURCE_MIDB = 38
    SOURCE_FOM = 39
    SOURCE_GALE = 40


class OverrideStatus(betterproto.Enum):
    """The state of an override."""

    OVERRIDE_STATUS_INVALID = 0
    OVERRIDE_STATUS_APPLIED = 1
    """the override was applied to the entity."""

    OVERRIDE_STATUS_PENDING = 2
    """the override is pending action."""

    OVERRIDE_STATUS_TIMEOUT = 3
    """the override has been timed out."""

    OVERRIDE_STATUS_REJECTED = 4
    """the override has been rejected"""

    OVERRIDE_STATUS_DELETION_PENDING = 5
    """The override is pending deletion."""


class OverrideType(betterproto.Enum):
    OVERRIDE_TYPE_INVALID = 0
    """
    The override type value was not set. This value is interpreted as
    OVERRIDE_TYPE_LIVE for backward compatibility.
    """

    OVERRIDE_TYPE_LIVE = 1
    """
    Override was requested when the entity was live according to the Entity
    Manager instance that handled the request.
    """

    OVERRIDE_TYPE_POST_EXPIRY = 2
    """
    Override was requested after the entity expired according to the Entity
    Manager instance that handled the request.
    """


class PayloadOperationalState(betterproto.Enum):
    """Describes the current operational state of a payload configuration."""

    PAYLOAD_OPERATIONAL_STATE_INVALID = 0
    PAYLOAD_OPERATIONAL_STATE_OFF = 1
    PAYLOAD_OPERATIONAL_STATE_NON_OPERATIONAL = 2
    PAYLOAD_OPERATIONAL_STATE_DEGRADED = 3
    PAYLOAD_OPERATIONAL_STATE_OPERATIONAL = 4
    PAYLOAD_OPERATIONAL_STATE_OUT_OF_SERVICE = 5
    PAYLOAD_OPERATIONAL_STATE_UNKNOWN = 6


class PowerStatus(betterproto.Enum):
    POWER_STATUS_INVALID = 0
    POWER_STATUS_UNKNOWN = 1
    """
    Indeterminate condition of whether the power system is present or absent.
    """

    POWER_STATUS_NOT_PRESENT = 2
    """
    Power system is not configured/present. This is considered a
    normal/expected condition, as opposed to the system is expected to be
    present but is missing.
    """

    POWER_STATUS_OPERATING = 3
    """Power system is present and operating normally."""

    POWER_STATUS_DISABLED = 4
    """
    Power system is present and is in an expected disabled state. For example,
    if the generator was shut off for operational reasons.
    """

    POWER_STATUS_ERROR = 5
    """Power system is non-functional."""


class PowerType(betterproto.Enum):
    POWER_TYPE_INVALID = 0
    POWER_TYPE_UNKNOWN = 1
    POWER_TYPE_GAS = 2
    POWER_TYPE_BATTERY = 3


class ModulationType(betterproto.Enum):
    """Enumerates the possible modulation types"""

    MODULATION_TYPE_INVALID = 0
    MODULATION_TYPE_AMPLITUDE = 1
    MODULATION_TYPE_FREQUENCY = 2
    MODULATION_TYPE_PHASE = 3
    MODULATION_TYPE_SPACED = 4
    MODULATION_TYPE_AMPLITUDE_SHIFT_KEYING = 5
    MODULATION_TYPE_FREQUENCY_SHIFT_KEYING = 6
    MODULATION_TYPE_PHASE_SHIFT_KEYING = 7
    MODULATION_TYPE_MINIMUM_SHIFT_KEYING = 8
    MODULATION_TYPE_MINIMUM_SHIFT_KEYING_GAUSSIAN = 9
    MODULATION_TYPE_SINGLE_SIDE_BAND_UPPER = 10
    MODULATION_TYPE_SINGLE_SIDE_BAND_LOWER = 11
    MODULATION_TYPE_SINGLE_SIDE_BAND_FULL_CARRIER = 12
    MODULATION_TYPE_SINGLE_SIDE_BAND_SUPPRESSED_CARRIER = 13
    MODULATION_TYPE_SINGLE_SIDE_BAND_REDUCED_CARRIER = 14
    MODULATION_TYPE_SINGLE_SIDE_BAND_WITHOUT_CARRIER = 15
    MODULATION_TYPE_DUAL_SIDE_BAND_FULL_CARRIER = 16
    MODULATION_TYPE_DUAL_SIDE_BAND_SUPPRESSED_CARRIER = 17
    MODULATION_TYPE_DUAL_SIDE_BAND_REDUCED_CARRIER = 18
    MODULATION_TYPE_DUAL_SIDE_BAND_WITHOUT_CARRIER = 19
    MODULATION_TYPE_INDEPENDENT_SIDE_BAND = 20
    MODULATION_TYPE_VESTIGIAL_SIDE_BAND = 21
    MODULATION_TYPE_ON_OFF_KEYING = 22
    MODULATION_TYPE_MULTI_FREQUENCY_SHIFT_KEYING = 23
    MODULATION_TYPE_AUDIO_FREQUENCY_SHIFT_KEYING = 24
    MODULATION_TYPE_CONTINUOUS_PHASE_FREQUENCY_SHIFT_KEYING = 25
    MODULATION_TYPE_C_PHASE_SHIFT_KEYING = 26
    MODULATION_TYPE_DIFFERENTIALLY_ENCODED_BINARY_PHASE_SHIFT_KEYING = 27
    MODULATION_TYPE_DIFFERENTIALLY_ENCODED_QUADRATURE_PHASE_SHIFT_KEYING = 28
    MODULATION_TYPE_OFFSET_QUADRATURE_PHASE_SHIFT_KEYING = 29
    MODULATION_TYPE_DIFFERENTIAL_PHASE_SHIFT_KEYING = 30
    MODULATION_TYPE_PI_4_QUADRATURE_PHASE_SHIFT_KEYING = 31
    MODULATION_TYPE_STACKED_OVERLAPPING_QUADRATURE_PHASE_SHIFT_KEYING = 32
    MODULATION_TYPE_F_QUADRATURE_PHASE_SHIFT_KEYING = 33
    MODULATION_TYPE_QUADRATURE_AMPLITUDE_ANALOG = 34
    MODULATION_TYPE_QUADRATURE_AMPLITUDE_DIGITAL = 35
    MODULATION_TYPE_CONTINUOUS_PHASE = 36
    MODULATION_TYPE_PULSE_POSITION = 37
    MODULATION_TYPE_TRELLIS_CODE = 38
    MODULATION_TYPE_ORTHOGONAL_FREQUENCY_DIVISION_MULTIPLEXING = 39
    MODULATION_TYPE_FREQUENCY_HOPPING_SPREAD_SPECTRUM = 40
    MODULATION_TYPE_DIGITAL_SEQUENCE_SPREAD_SPECTRUM = 41


class ScanType(betterproto.Enum):
    """Enumerates the possible scan types"""

    SCAN_TYPE_INVALID = 0
    SCAN_TYPE_CIRCULAR = 1
    SCAN_TYPE_BIDIRECTIONAL_HORIZONTAL_SECTOR = 2
    SCAN_TYPE_BIDIRECTIONAL_VERTICAL_SECTOR = 3
    SCAN_TYPE_NON_SCANNING = 4
    SCAN_TYPE_IRREGULAR = 5
    SCAN_TYPE_CONICAL = 6
    SCAN_TYPE_LOBE_SWITCHING = 7
    SCAN_TYPE_RASTER = 8
    SCAN_TYPE_CIRCULAR_VERTICAL_SECTOR = 9
    SCAN_TYPE_CIRCULAR_CONICAL = 10
    SCAN_TYPE_SECTOR_CONICAL = 11
    SCAN_TYPE_AGILE_BEAM = 12
    SCAN_TYPE_UNIDIRECTIONAL_VERTICAL_SECTOR = 13
    SCAN_TYPE_UNIDIRECTIONAL_HORIZONTAL_SECTOR = 14
    SCAN_TYPE_UNIDIRECTIONAL_SECTOR = 15
    SCAN_TYPE_BIDIRECTIONAL_SECTOR = 16


class OperationalState(betterproto.Enum):
    """Describes the current operational state of a system."""

    OPERATIONAL_STATE_INVALID = 0
    OPERATIONAL_STATE_OFF = 1
    """sensor exists but is deliberately turned off"""

    OPERATIONAL_STATE_NON_OPERATIONAL = 2
    """
    sensor is not operational but some reason other than being "Off" (e.g.,
    equipment malfunction)
    """

    OPERATIONAL_STATE_DEGRADED = 3
    """
    sensor is receiving information but in some reduced status (e.g., off
    calibration)
    """

    OPERATIONAL_STATE_OPERATIONAL = 4
    """fully functional"""

    OPERATIONAL_STATE_DENIED = 5
    """sensor is being actively denied"""


class SensorMode(betterproto.Enum):
    """
    Enumerates the possible sensor modes which were active for this sensor
    field of view.
    """

    SENSOR_MODE_INVALID = 0
    SENSOR_MODE_SEARCH = 1
    SENSOR_MODE_TRACK = 2
    SENSOR_MODE_WEAPON_SUPPORT = 3
    SENSOR_MODE_AUTO = 4
    SENSOR_MODE_MUTE = 5


class SensorType(betterproto.Enum):
    SENSOR_TYPE_INVALID = 0
    SENSOR_TYPE_RADAR = 1
    SENSOR_TYPE_CAMERA = 2
    SENSOR_TYPE_TRANSPONDER = 3
    SENSOR_TYPE_RF = 4
    SENSOR_TYPE_GPS = 5
    SENSOR_TYPE_PTU_POS = 6
    SENSOR_TYPE_WISP = 7
    SENSOR_TYPE_PERIMETER = 8
    SENSOR_TYPE_SONAR = 9


class ScheduleType(betterproto.Enum):
    """The type of Schedule."""

    SCHEDULE_TYPE_INVALID = 0
    SCHEDULE_TYPE_ZONE_ENABLED = 1
    SCHEDULE_TYPE_ZONE_TEMP_ENABLED = 2


class DodConditionCode(betterproto.Enum):
    """
    DOD Condition Codes as documented: DLM 4000.25, Volume 2, April 09, 2022
    Change 14. located at https://www.dla.mil/Defense-Data-
    Standards/Publications/Appendices/ Please refer to the DLM reference for
    more details about each condition code
    """

    DOD_CONDITION_CODE_INVALID = 0
    DOD_CONDITION_CODE_A = 1
    """Serviceable issuable without qualification (i.e., ready for use)"""

    DOD_CONDITION_CODE_B = 2
    """Serviceable issuable with qualification  (e.g., limited shelf life)"""

    DOD_CONDITION_CODE_C = 3
    """Serviceable priority issue (i.e., use before A or B)"""

    DOD_CONDITION_CODE_D = 4
    """Serviceable (requires test or modification)"""

    DOD_CONDITION_CODE_E = 5
    """Unserviceable but limited restoration required"""

    DOD_CONDITION_CODE_F = 6
    """
    Unserviceable Repairable (i.e., requires repair before ready for use)
    """

    DOD_CONDITION_CODE_G = 7
    """Unserviceable Incomplete (needs add't parts)"""

    DOD_CONDITION_CODE_H = 8
    """Unserviceable (Condemned; requires classification or analysis)"""

    DOD_CONDITION_CODE_Q = 9
    """Suspended (Product Deficiency)"""

    DOD_CONDITION_CODE_S = 10
    """
    Scrap. Materiel that has no value except for its basic materiel content
    """

    DOD_CONDITION_CODE_J = 11
    """Suspended (In Stock; requires classification or analysis)"""

    DOD_CONDITION_CODE_K = 12
    """Suspended (Returns)"""

    DOD_CONDITION_CODE_L = 13
    """Suspended (Litigation)"""

    DOD_CONDITION_CODE_M = 14
    """Suspended (In work; undergoing maintenance)"""

    DOD_CONDITION_CODE_N = 15
    """Suspended (Ammunition Suitable for Emergency Combat Use Only)"""

    DOD_CONDITION_CODE_P = 16
    """Unserviceable (Contains parts that could be reclaimed)"""

    DOD_CONDITION_CODE_R = 17
    """Suspended (Reclaimed items, awaiting condition determination)"""

    DOD_CONDITION_CODE_T = 18
    """Serviceable (Ammunition Suitable for Training Use Only)"""

    DOD_CONDITION_CODE_V = 19
    """Unserviceable (waste military munitions)"""

    DOD_CONDITION_CODE_X = 20
    """Suspended (repair decision delayed)"""


class InterrogationResponse(betterproto.Enum):
    """Indicates the interrogation status of a target."""

    INTERROGATION_RESPONSE_INVALID = 0
    """
    Note that INTERROGATION_INVALID indicates that the target has not been
    interrogated.
    """

    INTERROGATION_RESPONSE_CORRECT = 1
    INTERROGATION_RESPONSE_INCORRECT = 2
    INTERROGATION_RESPONSE_NO_RESPONSE = 3


class Deletable(betterproto.Enum):
    """
    Indicates whether an entity can be deleted with the DeleteEntity API call
    """

    DELETABLE_INVALID = 0
    DELETABLE_TRUE = 1
    """Entity can immediately be deleted."""

    DELETABLE_FALSE = 2
    """
    Entity is from another source that is known to not allow entities to be
    deleted
    """

    DELETABLE_REQUEST = 3
    """
    Entity is from another source that requires the source to accept the
    request. The DeleteEntity API call will work asynchronously in this case.
    """


class InteractivityMode(betterproto.Enum):
    INTERACTIVITY_MODE_INVALID = 0
    INTERACTIVITY_MODE_DEFAULT = 1
    INTERACTIVITY_MODE_DISABLED_ON_MAP = 2


class EventType(betterproto.Enum):
    """The type of entity event."""

    EVENT_TYPE_INVALID = 0
    EVENT_TYPE_CREATED = 1
    """entity was created."""

    EVENT_TYPE_UPDATE = 2
    """entity was updated."""

    EVENT_TYPE_DELETED = 3
    """entity was deleted."""

    EVENT_TYPE_PREEXISTING = 4
    """entity already existed, but sent on a new stream connection."""

    EVENT_TYPE_POST_EXPIRY_OVERRIDE = 5
    """entity override was set after the entity expiration."""


@dataclass(eq=False, repr=False)
class Location(betterproto.Message):
    """Available for Entities that have a single or primary Location."""

    position: "Position" = betterproto.message_field(1)
    """
    see Position definition for details. We opt not to use anduril type for
    altitude clarity.
    """

    velocity_enu: "__type__.Enu" = betterproto.message_field(2)
    """
    Velocity in an ENU reference frame centered on the corresponding position.
    All units are meters per second.
    """

    speed_mps: Optional[float] = betterproto.message_field(
        5, wraps=betterproto.TYPE_DOUBLE
    )
    """
    Speed is the magnitude of velocity_enu vector [sqrt(e^2 + n^2 + u^2)] when
    present, measured in m/s.
    """

    acceleration: "__type__.Enu" = betterproto.message_field(4)
    """The entity's acceleration in meters/s^2."""

    attitude_enu: "__type__.Quaternion" = betterproto.message_field(3)
    """quaternion to translate from entity body frame to it's ENU frame"""


@dataclass(eq=False, repr=False)
class Position(betterproto.Message):
    """WGS84 position."""

    latitude_degrees: float = betterproto.double_field(1)
    """WGS84 geodetic latitude in decimal degrees."""

    longitude_degrees: float = betterproto.double_field(2)
    """WGS84 longitude in decimal degrees."""

    altitude_hae_meters: Optional[float] = betterproto.message_field(
        3, wraps=betterproto.TYPE_DOUBLE
    )
    """
    altitude as height above ellipsoid (WGS84) in meters. DoubleValue wrapper
    is used to distinguish optional from default 0.
    """

    altitude_agl_meters: Optional[float] = betterproto.message_field(
        4, wraps=betterproto.TYPE_DOUBLE
    )
    """
    Altitude as AGL (Above Ground Level) if the upstream data source has this
    value set. If the value is not set from the upstream, this value is not
    set.
    """

    altitude_asf_meters: Optional[float] = betterproto.message_field(
        5, wraps=betterproto.TYPE_DOUBLE
    )
    """
    Altitude as ASF (Above Sea Floor) if the upstream data source has this
    value set. If the value is not set from the upstream, this value is not
    set.
    """

    pressure_depth_meters: Optional[float] = betterproto.message_field(
        6, wraps=betterproto.TYPE_DOUBLE
    )
    """
    Depth in meters measures the depth of the entity from the surface of the
    water through sensor measurements based on differential pressure between
    the interior and exterior of the vessel. If the value is not set from the
    upstream, this value is not set.
    """


@dataclass(eq=False, repr=False)
class LocationUncertainty(betterproto.Message):
    """Uncertainty of entity position and velocity, if available."""

    position_enu_cov: "TMat3" = betterproto.message_field(1)
    """
    Positional covariance represented by the upper triangle of the covariance
    matrix.
    """

    velocity_enu_cov: "TMat3" = betterproto.message_field(2)
    """
    Velocity covariance represented by the upper triangle of the covariance
    matrix.
    """

    position_error_ellipse: "ErrorEllipse" = betterproto.message_field(3)
    """
    An ellipse that describes the certainty probability and error boundary for
    a given geolocation.
    """


@dataclass(eq=False, repr=False)
class ErrorEllipse(betterproto.Message):
    """
    Indicates ellipse characteristics and probability that an entity lies
    within the defined ellipse.
    """

    probability: Optional[float] = betterproto.message_field(
        1, wraps=betterproto.TYPE_DOUBLE
    )
    """
    Defines the probability in percentage that an entity lies within the given
    ellipse: 0-1.
    """

    semi_major_axis_m: Optional[float] = betterproto.message_field(
        2, wraps=betterproto.TYPE_DOUBLE
    )
    """
    Defines the distance from the center point of the ellipse to the furthest
    distance on the perimeter in meters.
    """

    semi_minor_axis_m: Optional[float] = betterproto.message_field(
        3, wraps=betterproto.TYPE_DOUBLE
    )
    """
    Defines the distance from the center point of the ellipse to the shortest
    distance on the perimeter in meters.
    """

    orientation_d: Optional[float] = betterproto.message_field(
        4, wraps=betterproto.TYPE_DOUBLE
    )
    """
    The orientation of the semi-major relative to true north in degrees from
    clockwise: 0-180 due to symmetry across the semi-minor axis.
    """


@dataclass(eq=False, repr=False)
class Pose(betterproto.Message):
    """Overrides anduril.type.Pose."""

    pos: "Position" = betterproto.message_field(1)
    """Geospatial location defined by this Pose."""

    orientation: "__type__.Quaternion" = betterproto.message_field(2)
    """
    The quaternion to transform a point in the Pose frame to the ENU frame. The
    Pose frame could be Body, Turret, etc and is determined by the context in
    which this Pose is used. The normal convention for defining orientation is
    to list the frames of transformation, for example att_gimbal_to_enu is the
    quaternion which transforms a point in the gimbal frame to the body frame,
    but in this case we truncate to att_enu because the Pose frame isn't
    defined. A potentially better name for this field would have been
    att_pose_to_enu. Implementations of this quaternion should left multiply
    this quaternion to transform a point from the Pose frame to the enu frame.
    """


@dataclass(eq=False, repr=False)
class TMat3(betterproto.Message):
    """Symmetric 3d matrix only representing the upper right triangle."""

    mxx: float = betterproto.float_field(1)
    mxy: float = betterproto.float_field(2)
    mxz: float = betterproto.float_field(3)
    myy: float = betterproto.float_field(4)
    myz: float = betterproto.float_field(5)
    mzz: float = betterproto.float_field(6)


@dataclass(eq=False, repr=False)
class GeoDetails(betterproto.Message):
    """A component that describes a geo-entity."""

    type: "GeoType" = betterproto.enum_field(1)
    emergency: "EmergencyDetails" = betterproto.message_field(2, group="type_details")
    fscm: "FscmDetails" = betterproto.message_field(4, group="type_details")
    control_area: "ControlAreaDetails" = betterproto.message_field(
        5, group="type_details"
    )
    acm: "AcmDetails" = betterproto.message_field(6, group="type_details")
    mcm: "McmDetails" = betterproto.message_field(7, group="type_details")
    visual_details: "GeoVisualDetails" = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class EmergencyDetails(betterproto.Message):
    """Details specific to a geo-entity of emergency type."""

    emergency_type: "EmergencyType" = betterproto.enum_field(1)
    personnel_involved: int = betterproto.uint32_field(2)


@dataclass(eq=False, repr=False)
class GeoShape(betterproto.Message):
    """A component that describes the shape of a geo-entity."""

    point: "GeoPoint" = betterproto.message_field(1, group="shape")
    line: "GeoLine" = betterproto.message_field(2, group="shape")
    polygon: "GeoPolygon" = betterproto.message_field(3, group="shape")
    ellipse: "GeoEllipse" = betterproto.message_field(4, group="shape")
    ellipsoid: "GeoEllipsoid" = betterproto.message_field(5, group="shape")


@dataclass(eq=False, repr=False)
class GeoPoint(betterproto.Message):
    """
    A point shaped geo-entity. See
    https://datatracker.ietf.org/doc/html/rfc7946#section-3.1.2
    """

    position: "Position" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class GeoLine(betterproto.Message):
    """
    A line shaped geo-entity. See
    https://datatracker.ietf.org/doc/html/rfc7946#section-3.1.4
    """

    positions: List["Position"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class GeoPolygon(betterproto.Message):
    """
    A polygon shaped geo-entity. See
    https://datatracker.ietf.org/doc/html/rfc7946#section-3.1.6, only canonical
    representations accepted
    """

    rings: List["LinearRing"] = betterproto.message_field(1)
    """
    An array of LinearRings where the first item is the exterior ring and
    subsequent items are interior rings. For a good introduction read
    (https://macwright.com/2015/03/23/geojson-second-bite.html#polygons)
    """

    is_rectangle: bool = betterproto.bool_field(2)
    """
    An extension hint that this polygon is a rectangle. When true this implies
    several things: * exactly 1 linear ring with 5 points (starting corner, 3
    other corners and start again) * each point has the same altitude
    corresponding with the plane of the rectangle * each point has the same
    height (either all present and equal, or all not present)
    """


@dataclass(eq=False, repr=False)
class GeoEllipse(betterproto.Message):
    """
    An ellipse shaped geo-entity. For a circle, the major and minor axis would
    be the same values. This shape is NOT Geo-JSON compatible.
    """

    semi_major_axis_m: Optional[float] = betterproto.message_field(
        2, wraps=betterproto.TYPE_DOUBLE
    )
    """
    Defines the distance from the center point of the ellipse to the furthest
    distance on the perimeter in meters.
    """

    semi_minor_axis_m: Optional[float] = betterproto.message_field(
        3, wraps=betterproto.TYPE_DOUBLE
    )
    """
    Defines the distance from the center point of the ellipse to the shortest
    distance on the perimeter in meters.
    """

    orientation_d: Optional[float] = betterproto.message_field(
        4, wraps=betterproto.TYPE_DOUBLE
    )
    """
    The orientation of the semi-major relative to true north in degrees from
    clockwise: 0-180 due to symmetry across the semi-minor axis.
    """

    height_m: Optional[float] = betterproto.message_field(
        5, wraps=betterproto.TYPE_DOUBLE
    )
    """
    Optional height above entity position to extrude in meters. A non-zero
    value creates an elliptic cylinder
    """


@dataclass(eq=False, repr=False)
class GeoEllipsoid(betterproto.Message):
    """
    An ellipsoid shaped geo-entity. Principal axis lengths are defined in
    entity body space This shape is NOT Geo-JSON compatible.
    """

    forward_axis_m: Optional[float] = betterproto.message_field(
        1, wraps=betterproto.TYPE_DOUBLE
    )
    """
    Defines the distance from the center point to the surface along the forward
    axis
    """

    side_axis_m: Optional[float] = betterproto.message_field(
        2, wraps=betterproto.TYPE_DOUBLE
    )
    """
    Defines the distance from the center point to the surface along the side
    axis
    """

    up_axis_m: Optional[float] = betterproto.message_field(
        3, wraps=betterproto.TYPE_DOUBLE
    )
    """
    Defines the distance from the center point to the surface along the up axis
    """


@dataclass(eq=False, repr=False)
class LinearRing(betterproto.Message):
    """A closed ring of points. The first and last point must be the same."""

    points: List["Position"] = betterproto.message_field(1)
    """Deprecated: do not use, use positions instead"""

    positions: List["GeoPolygonPosition"] = betterproto.message_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("points"):
            warnings.warn("LinearRing.points is deprecated", DeprecationWarning)


@dataclass(eq=False, repr=False)
class GeoPolygonPosition(betterproto.Message):
    """A position in a GeoPolygon with an optional extruded height."""

    position: "Position" = betterproto.message_field(1)
    """base position. if no altitude set, its on the ground."""

    height_m: Optional[float] = betterproto.message_field(
        2, wraps=betterproto.TYPE_FLOAT
    )
    """
    optional height above base position to extrude in meters. for a given
    polygon, all points should have a height or none of them. strictly GeoJSON
    compatible polygons will not have this set.
    """


@dataclass(eq=False, repr=False)
class GeoVisualDetails(betterproto.Message):
    """Details specific to displaying a geo-entity"""

    fill_color: "__type__.Color" = betterproto.message_field(1)
    """A string describing the fill color of a geo-entity."""

    line_color: "__type__.Color" = betterproto.message_field(2)
    """A string describing the line color of a geo-entity."""


@dataclass(eq=False, repr=False)
class FscmDetails(betterproto.Message):
    """
    Details specific to a geo-entity of Fire Support Coordination Measure
    (FSCM) type
    """

    fscm_type: "FscmDetailType" = betterproto.enum_field(1)
    fscm_description: str = betterproto.string_field(2)
    """
    Used for loosely typed associations, such as assignment to a specific fires
    unit Limit to 150 characters
    """

    firing_authority: "FiringAuthority" = betterproto.message_field(3)
    ammo_restriction_type: "AmmoRestrictionType" = betterproto.enum_field(4)
    restrictive_measure_type: "RestrictiveMeasureType" = betterproto.enum_field(5)
    ammo_restrict_types: List["AmmoRestrictionType"] = betterproto.enum_field(6)
    is_ground: bool = betterproto.bool_field(7)
    """
    Used to indicate distinction between an FSCM applying to either air or
    ground, never both
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("ammo_restriction_type"):
            warnings.warn(
                "FscmDetails.ammo_restriction_type is deprecated", DeprecationWarning
            )


@dataclass(eq=False, repr=False)
class AcmDetails(betterproto.Message):
    acm_type: "AcmDetailType" = betterproto.enum_field(1)
    acm_description: str = betterproto.string_field(2)
    """
    Used for loosely typed associations, such as assignment to a specific fires
    unit Limit to 150 characters
    """


@dataclass(eq=False, repr=False)
class McmDetails(betterproto.Message):
    mcm_type: "McmDetailType" = betterproto.enum_field(1)
    mcm_description: str = betterproto.string_field(2)
    """
    Used for loosely typed associations, such as assignment to a specific fires
    unit Limit to 150 characters
    """


@dataclass(eq=False, repr=False)
class FiringAuthority(betterproto.Message):
    """
    Lists the entities that have authority to execute fires into, or through,
    this FSCM
    """

    entity_ids: List[str] = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class ControlAreaDetails(betterproto.Message):
    """
    Details specific to a geo-entity of the GEO_TYPE_CONTROL_AREA type,
    representing an autonomous asset Control Area.
    """

    type: "ControlAreaType" = betterproto.enum_field(1)


@dataclass(eq=False, repr=False)
class Statement(betterproto.Message):
    """
    A Statement is the building block of the entity filter. The outermost
    statement is conceptually the root node of an "expression tree" which
    allows for the construction of complete boolean logic statements.
    Statements are formed by grouping sets of children statement(s) or
    predicate(s) according to the boolean operation which is to be applied. For
    example, the criteria "take an action if an entity is hostile and an air
    vehicle" can be represented as: Statement1: { AndOperation: { Predicate1,
    Predicate2 } }. Where Statement1 is the root of the expression tree, with
    an AND operation that is applied to children predicates. The predicates
    themselves encode "entity is hostile" and "entity is air vehicle."
    """

    and_: "AndOperation" = betterproto.message_field(1, group="operation")
    or_: "OrOperation" = betterproto.message_field(2, group="operation")
    not_: "NotOperation" = betterproto.message_field(3, group="operation")
    list: "ListOperation" = betterproto.message_field(4, group="operation")
    predicate: "Predicate" = betterproto.message_field(5, group="operation")


@dataclass(eq=False, repr=False)
class AndOperation(betterproto.Message):
    """
    The AndOperation represents the boolean AND operation, which is to be
    applied to the list of children statement(s) or predicate(s).
    """

    predicate_set: "PredicateSet" = betterproto.message_field(1, group="children")
    statement_set: "StatementSet" = betterproto.message_field(2, group="children")


@dataclass(eq=False, repr=False)
class OrOperation(betterproto.Message):
    """
    The OrOperation represents the boolean OR operation, which is to be applied
    to the list of children statement(s) or predicate(s).
    """

    predicate_set: "PredicateSet" = betterproto.message_field(1, group="children")
    statement_set: "StatementSet" = betterproto.message_field(2, group="children")


@dataclass(eq=False, repr=False)
class NotOperation(betterproto.Message):
    """
    The NotOperation represents the boolean NOT operation, which can only be
    applied to a single child predicate or statement.
    """

    predicate: "Predicate" = betterproto.message_field(1, group="child")
    statement: "Statement" = betterproto.message_field(2, group="child")


@dataclass(eq=False, repr=False)
class ListOperation(betterproto.Message):
    """
    The ListOperation represents an operation against a proto list. If the list
    is of primitive proto type (e.g. int32), paths in all child predicates
    should be left empty. If the list is of message proto type (e.g. Sensor),
    paths in all child predicates should be relative to the list path. For
    example, the criteria "take an action if an entity has any sensor with
    sensor_id='sensor' and OperationalState=STATE_OFF" would be modeled as:
    Predicate1: { path: "sensor_id", comparator: EQUAL_TO, value: "sensor" }
    Predicate2: { path: "operational_state", comparator: EQUAL_TO, value:
    STATE_OFF } Statement2: { AndOperation: PredicateSet: { <Predicate1>,
    <Predicate2> } } ListOperation: { list_path: "sensors.sensors",
    list_comparator: ANY, statement: <Statement2> } Statement1: {
    ListOperation: <ListOperation> } Note that in the above, the child
    predicates of the list operation have paths relative to the list_path
    because the list is comprised of message not primitive types.
    """

    list_path: str = betterproto.string_field(1)
    """
    The list_path specifies the repeated field on an entity to which this
    operation applies.
    """

    list_comparator: "ListComparator" = betterproto.enum_field(2)
    """
    The list_comparator specifies how to compose the boolean results from the
    child statement for each member of the specified list.
    """

    statement: "Statement" = betterproto.message_field(3)
    """
    The statement is a new expression tree conceptually rooted at type of the
    list. It determines how each member of the list is evaluated.
    """


@dataclass(eq=False, repr=False)
class PredicateSet(betterproto.Message):
    """
    The PredicateSet represents a list of predicates or "leaf nodes" in the
    expression tree, which can be directly evaluated to a boolean TRUE/FALSE
    result.
    """

    predicates: List["Predicate"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class StatementSet(betterproto.Message):
    """
    The StatementSet represents a list of statements or "tree nodes," each of
    which follow the same behavior as the Statement proto message.
    """

    statements: List["Statement"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class Predicate(betterproto.Message):
    """
    The Predicate fully encodes the information required to make an evaluation
    of an entity field against a given static value, resulting in a boolean
    TRUE/FALSE result. The structure of a predicate will always follow:
    "{entity-value} {comparator} {fixed-value}" where the entity value is
    determined by the field path. For example, a predicate would read as:
    "{entity.location.velocity_enu} {LESS_THAN} {500kph}"
    """

    field_path: str = betterproto.string_field(1)
    """
    The field_path determines which field on an entity is being referenced in
    this predicate. For example: correlated.primary_entity_id would be
    primary_entity_id in correlated component.
    """

    value: "Value" = betterproto.message_field(2)
    """
    The value determines the fixed value against which the entity field is to
    be compared. In the case of COMPARATOR_MATCH_ALL, the value contents do not
    matter as long as the Value is a supported type.
    """

    comparator: "Comparator" = betterproto.enum_field(3)
    """
    The comparator determines the manner in which the entity field and static
    value are compared. Comparators may only be applied to certain values. For
    example, the WITHIN comparator cannot be used for a boolean value
    comparison.
    """


@dataclass(eq=False, repr=False)
class Value(betterproto.Message):
    """
    The Value represents the information against which an entity field is
    evaluated. It is one of a fixed set of types, each of which correspond to
    specific comparators. See "ComparatorType" for the full list of Value <->
    Comparator mappings.
    """

    boolean_type: "BooleanType" = betterproto.message_field(1, group="type")
    numeric_type: "NumericType" = betterproto.message_field(2, group="type")
    string_type: "StringType" = betterproto.message_field(3, group="type")
    enum_type: "EnumType" = betterproto.message_field(4, group="type")
    timestamp_type: "TimestampType" = betterproto.message_field(5, group="type")
    bounded_shape_type: "BoundedShapeType" = betterproto.message_field(6, group="type")
    position_type: "PositionType" = betterproto.message_field(7, group="type")
    heading_type: "HeadingType" = betterproto.message_field(8, group="type")
    list_type: "ListType" = betterproto.message_field(9, group="type")
    range_type: "RangeType" = betterproto.message_field(10, group="type")


@dataclass(eq=False, repr=False)
class BooleanType(betterproto.Message):
    """The BooleanType represents a static boolean value."""

    value: bool = betterproto.bool_field(1)


@dataclass(eq=False, repr=False)
class NumericType(betterproto.Message):
    """
    The NumericType represents static numeric values. It supports all numeric
    primitives supported by the proto3 language specification.
    """

    double_value: float = betterproto.double_field(1, group="value")
    float_value: float = betterproto.float_field(2, group="value")
    int32_value: int = betterproto.int32_field(3, group="value")
    int64_value: int = betterproto.int64_field(4, group="value")
    uint32_value: int = betterproto.uint32_field(5, group="value")
    uint64_value: int = betterproto.uint64_field(6, group="value")


@dataclass(eq=False, repr=False)
class StringType(betterproto.Message):
    """The StringType represents static string values."""

    value: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class EnumType(betterproto.Message):
    """
    The EnumType represents members of well-known anduril ontologies, such as
    "disposition." When such a value is specified, the evaluation library
    expects the integer representation of the enum value. For example, a
    disposition derived from ontology.v1 such as "DISPOSITION_HOSTILE" should
    be represented with the integer value 2.
    """

    value: int = betterproto.int32_field(1)


@dataclass(eq=False, repr=False)
class ListType(betterproto.Message):
    """A List of Values for use with the IN comparator."""

    values: List["Value"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class TimestampType(betterproto.Message):
    """The TimestampType represents a static timestamp value."""

    value: datetime = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class PositionType(betterproto.Message):
    """The PositionType represents any fixed LLA point in space."""

    value: "Position" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class BoundedShapeType(betterproto.Message):
    """The BoundedShapeType represents any static fully-enclosed shape."""

    polygon_value: "GeoPolygon" = betterproto.message_field(1, group="value")


@dataclass(eq=False, repr=False)
class HeadingType(betterproto.Message):
    """
    The HeadingType represents the heading in degrees for an entity's
    attitudeEnu quaternion to be compared against. Defaults between a range of
    0 to 360
    """

    value: int = betterproto.int32_field(1)


@dataclass(eq=False, repr=False)
class RangeType(betterproto.Message):
    """
    The RangeType represents a numeric range. Whether endpoints are included
    are based on the comparator used. Both endpoints must be of the same
    numeric type.
    """

    start: "NumericType" = betterproto.message_field(1)
    end: "NumericType" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class DynamicStatement(betterproto.Message):
    """
    A DynamicStatement is the building block of a "runtime aware" entity filter
    - that is, any filter which needs to perform operations against a series of
    entities that will need to be evaluated against on demand. The
    DynamicStatement allows you to perform a set intersection operation across
    a static set of entities dictated by a filter, and a dynamic set of
    entities dictated by a selector statement. For example, the expression
    "find me all hostile entities that reside within any assumed friendly
    geoentity" would be represented as the following dynamic statement:
    DynamicStatement    filter      predicate        field_path:
    mil_view.disposition        comparator: EQUALITY        value: 2 // Hostile
    selector      andOperation        predicate1          field_path:
    mil_view.disposition          comparator: EQUALITY          value: 4 //
    Assumed Friendly        predicate2          field_path: ontology.template
    comparator: EQUALITY          value: 4 // Template Geo    comparator
    IntersectionComparator        WithinComparison
    """

    filter: "Statement" = betterproto.message_field(1)
    """
    The filter statement is used to determine which entities can be compared to
    the dynamic series of entities aggregated by the selector statement.
    """

    selector: "Statement" = betterproto.message_field(2)
    """
    The selector statement is used to determine which entities should be a part
    of dynamically changing set. The selector should be reevaluated as entites
    are created or deleted.
    """

    comparator: "IntersectionComparator" = betterproto.message_field(3)
    """
    The comparator specifies how the set intersection operation will be
    performed.
    """


@dataclass(eq=False, repr=False)
class IntersectionComparator(betterproto.Message):
    """
    The IntersectionComparator determines what entities and what fields to
    respect within a set during a set intersection operation.
    """

    within_comparison: "WithinComparison" = betterproto.message_field(
        1, group="comparison"
    )


@dataclass(eq=False, repr=False)
class WithinComparison(betterproto.Message):
    """
    The WithinComparison implicitly will understand how to determine which
    entitites reside within other geo-shaped entities. This comparison is being
    left empty, but as a proto, to support future expansions of the within
    comparison (eg; within range of a static distance).
    """

    pass


@dataclass(eq=False, repr=False)
class Classification(betterproto.Message):
    """
    A component that describes an entity's security classification levels.
    """

    level: "ClassificationLevels" = betterproto.enum_field(1)
    default: "ClassificationInformation" = betterproto.message_field(2)
    """
    The default classification information which should be assumed to apply to
    everything in the entity unless a specific field level classification is
    present.
    """

    fields: List["FieldClassificationInformation"] = betterproto.message_field(3)
    """
    The set of individual field classification information which should always
    precedence over the default classification information.
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("level"):
            warnings.warn("Classification.level is deprecated", DeprecationWarning)


@dataclass(eq=False, repr=False)
class FieldClassificationInformation(betterproto.Message):
    """A field specific classification information definition."""

    field_path: str = betterproto.string_field(1)
    """
    Proto field path which is the string representation of a field. > example:
    signal.bandwidth_hz would be bandwidth_hz in the signal component
    """

    classification_information: "ClassificationInformation" = betterproto.message_field(
        2
    )
    """
    The information which makes up the field level classification marking.
    """


@dataclass(eq=False, repr=False)
class ClassificationInformation(betterproto.Message):
    """
    Represents all of the necessary information required to generate a
    summarized classification marking. > example: A summarized classification
    marking of "TOPSECRET//NOFORN//FISA"            would be defined as: {
    "level": 5, "caveats": [ "NOFORN, "FISA" ] }
    """

    level: "ClassificationLevels" = betterproto.enum_field(1)
    """Classification level to be applied to the information in question."""

    caveats: List[str] = betterproto.string_field(2)
    """
    Caveats that may further restrict how the information can be disseminated.
    """


@dataclass(eq=False, repr=False)
class ContactDetails(betterproto.Message):
    """Contains details on how to make contact with an entity."""

    phone_number: str = betterproto.string_field(1)
    """The primary phone number for this entity."""


@dataclass(eq=False, repr=False)
class Correlated(betterproto.Message):
    """
    Available for Entities that are a correlated (N to 1) set of entities. This
    will be present on each entity in the set.
    """

    primary_entity_id: str = betterproto.string_field(1)
    """primary entity id"""

    status: "CorrelationStatus" = betterproto.enum_field(2)
    """status representing this correlation"""

    scores: List["CorrelationScore"] = betterproto.message_field(3)
    """score pairings between this and other entity ids"""

    expires_time: datetime = betterproto.message_field(4)
    """if not present, does not expire"""


@dataclass(eq=False, repr=False)
class CorrelationScore(betterproto.Message):
    """A correlation scoring between two entities."""

    other_entity_id: str = betterproto.string_field(1)
    score: float = betterproto.float_field(2)
    interpretation: "ScoreInterpretation" = betterproto.enum_field(3)
    link16_compliant: bool = betterproto.bool_field(4)
    """Deprecated: do not use"""

    other_status: "CorrelationStatus" = betterproto.enum_field(5)
    """
    status of other_entity_id correlation, expresses relationship of other to
    correlation set this entity is part of.
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("link16_compliant"):
            warnings.warn(
                "CorrelationScore.link16_compliant is deprecated", DeprecationWarning
            )


@dataclass(eq=False, repr=False)
class Dimensions(betterproto.Message):
    length_m: float = betterproto.float_field(1)
    """Length of the entity in meters"""


@dataclass(eq=False, repr=False)
class GroupDetails(betterproto.Message):
    """Details related to grouping for this entity"""

    team: "Team" = betterproto.message_field(1, group="group_type")


@dataclass(eq=False, repr=False)
class Team(betterproto.Message):
    """
    Describes a Team group type. Comprised of autonomous assets where an asset
    in a Team can only be a part of a single Team at a time.
    """

    pass


@dataclass(eq=False, repr=False)
class ComponentMessage(betterproto.Message):
    """A message describing the component's health status."""

    status: "HealthStatus" = betterproto.enum_field(1)
    """The status associated with this message."""

    message: str = betterproto.string_field(2)
    """The human-readable content of the message."""


@dataclass(eq=False, repr=False)
class ComponentHealth(betterproto.Message):
    """Health of an individual component."""

    id: str = betterproto.string_field(1)
    """Consistent internal ID for this component."""

    name: str = betterproto.string_field(2)
    """Display name for this component."""

    health: "HealthStatus" = betterproto.enum_field(3)
    """Health for this component."""

    messages: List["ComponentMessage"] = betterproto.message_field(4)
    """
    Human-readable describing the component state. These messages should be
    understandable by end users.
    """

    update_time: datetime = betterproto.message_field(5)
    """
    The last update time for this specific component. If this timestamp is
    unset, the data is assumed to be most recent
    """


@dataclass(eq=False, repr=False)
class Health(betterproto.Message):
    """General health of the entity as reported by the entity."""

    connection_status: "ConnectionStatus" = betterproto.enum_field(1)
    """
    Status indicating whether the entity is able to communicate with Entity
    Manager.
    """

    health_status: "HealthStatus" = betterproto.enum_field(2)
    """
    Top-level health status; typically a roll-up of individual component
    healths.
    """

    components: List["ComponentHealth"] = betterproto.message_field(3)
    """Health of individual components running on this Entity."""

    update_time: datetime = betterproto.message_field(4)
    """
    The update time for the top-level health information. If this timestamp is
    unset, the data is assumed to be most recent
    """


@dataclass(eq=False, repr=False)
class Media(betterproto.Message):
    """Media associated with an entity."""

    media: List["MediaItem"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class MediaItem(betterproto.Message):
    url: str = betterproto.string_field(1)
    """
    To Be Deprecated, use relative_path. The url where the media related to an
    entity can be accessed
    """

    type: "MediaType" = betterproto.enum_field(2)
    relative_path: str = betterproto.string_field(3)
    """
    The relative path where the media related to an entity can be accessed when
    used to query against a blobs service node.
    """


@dataclass(eq=False, repr=False)
class UInt32Range(betterproto.Message):
    lower_bound: int = betterproto.uint32_field(1)
    upper_bound: int = betterproto.uint32_field(2)


@dataclass(eq=False, repr=False)
class FloatRange(betterproto.Message):
    lower_bound: float = betterproto.float_field(1)
    upper_bound: float = betterproto.float_field(2)


@dataclass(eq=False, repr=False)
class MilView(betterproto.Message):
    """Available for Entities that have a military view representation."""

    disposition: "__ontology_v1__.Disposition" = betterproto.enum_field(1)
    environment: "__ontology_v1__.Environment" = betterproto.enum_field(2)
    nationality: "__ontology_v1__.Nationality" = betterproto.enum_field(3)


@dataclass(eq=False, repr=False)
class Ontology(betterproto.Message):
    """Ontology of the entity."""

    descriptors: List[str] = betterproto.string_field(1)
    """DEPRECATED: list of possible descriptors in preferred order."""

    krn: str = betterproto.string_field(5)
    """
    KRN: Knowledge Resource Name A string that references the ontology of the
    entity defined in KnowledgeGraph.
    """

    platform_type: str = betterproto.string_field(3)
    """
    A string that describes the asset's high-level type with natural language.
    These values include, but are not limited to the
    AIR/SURFACE/SUBSURFACE/LAND/SPACE PLATFORM TYPE values found in MIL-STD
    6016F. Examples include "FIGHTER", "TANK", "AIRCRAFT CARRIER", "UAV".
    """

    specific_type: str = betterproto.string_field(4)
    """
    A string that describes the asset's exact model or type. These values
    include, but are not limited to the AIR/SURFACE/SUBSURFACE/LAND/SPACE
    SPECIFIC TYPE values found in MIL-STD 6016F. Examples include "F-16",
    "NASAMS-LCHR", "ARLEIGH BURKE DDG", "GHOST".
    """

    template: "Template" = betterproto.enum_field(2)
    """
    The template used when creating this entity. Specifies minimum required
    components.
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("descriptors"):
            warnings.warn("Ontology.descriptors is deprecated", DeprecationWarning)


@dataclass(eq=False, repr=False)
class Payloads(betterproto.Message):
    """List of payloads available for an entity. i.e a weapon."""

    payload_configurations: List["Payload"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class Payload(betterproto.Message):
    """Individual payload configuration."""

    config: "PayloadConfiguration" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class PayloadConfiguration(betterproto.Message):
    """
    The configuration for this capability, published on the
    CAPABILITY_TOPIC_PAYLOAD_CONFIGURATION topic id.
    """

    capability_id: str = betterproto.string_field(1)
    """
    Identifying ID for the capability. This ID may be used multiple times to
    represent payloads that are the same capability but have different
    operational states
    """

    quantity: int = betterproto.uint32_field(4)
    """The number of payloads currently available in the configuration."""

    effective_environment: List["__ontology_v1__.Environment"] = betterproto.enum_field(
        5
    )
    """The target environments the configuration is effective against."""

    payload_operational_state: "PayloadOperationalState" = betterproto.enum_field(6)
    """The operational state of this payload."""

    payload_description: str = betterproto.string_field(7)
    """A human readable description of the payload"""


@dataclass(eq=False, repr=False)
class PowerState(betterproto.Message):
    """Represents the state of power sources connected to this entity."""

    source_id_to_state: Dict[str, "PowerSource"] = betterproto.map_field(
        5, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
    power_status: "PowerStatus" = betterproto.enum_field(1)
    power_type: "PowerType" = betterproto.enum_field(2)
    power_level: "PowerLevel" = betterproto.message_field(3)
    messages: List[str] = betterproto.string_field(4)

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("power_status"):
            warnings.warn("PowerState.power_status is deprecated", DeprecationWarning)
        if self.is_set("power_type"):
            warnings.warn("PowerState.power_type is deprecated", DeprecationWarning)
        if self.is_set("power_level"):
            warnings.warn("PowerState.power_level is deprecated", DeprecationWarning)
        if self.is_set("messages"):
            warnings.warn("PowerState.messages is deprecated", DeprecationWarning)


@dataclass(eq=False, repr=False)
class PowerSource(betterproto.Message):
    """
    Represents the state of a single power source that is connected to this
    entity.
    """

    power_status: "PowerStatus" = betterproto.enum_field(1)
    """Status of the power source."""

    power_type: "PowerType" = betterproto.enum_field(2)
    """Used to determine the type of power source."""

    power_level: "PowerLevel" = betterproto.message_field(3)
    """
    Power level of the system. If absent, the power level is assumed to be
    unknown.
    """

    messages: List[str] = betterproto.string_field(4)
    """
    Set of human-readable messages with status of the power system. Typically
    this would be used in an error state to provide additional error
    information. This can also be used for informational messages.
    """

    offloadable: Optional[bool] = betterproto.message_field(
        5, wraps=betterproto.TYPE_BOOL
    )
    """
    Whether the power source is offloadable. If the value is missing (as
    opposed to false) then the entity does not report whether the power source
    is offloadable.
    """


@dataclass(eq=False, repr=False)
class PowerLevel(betterproto.Message):
    """Represents the power level of a system."""

    capacity: float = betterproto.float_field(1)
    """Total power capacity of the system."""

    remaining: float = betterproto.float_field(2)
    """Remaining power capacity of the system."""

    percent_remaining: float = betterproto.float_field(3)
    """Percent of power remaining."""

    voltage: Optional[float] = betterproto.message_field(
        4, wraps=betterproto.TYPE_DOUBLE
    )
    """
    Voltage of the power source subsystem, as reported by the power source. If
    the source does not report this value this field will be null.
    """

    current_amps: Optional[float] = betterproto.message_field(
        5, wraps=betterproto.TYPE_DOUBLE
    )
    """
    Current in amps of the power source subsystem, as reported by the power
    source. If the source does not report this value this field will be null.
    """

    run_time_to_empty_mins: Optional[float] = betterproto.message_field(
        6, wraps=betterproto.TYPE_DOUBLE
    )
    """
    Estimated minutes until empty. Calculated with consumption at the moment,
    as reported by the power source. If the source does not report this value
    this field will be null.
    """

    consumption_rate_l_per_s: Optional[float] = betterproto.message_field(
        7, wraps=betterproto.TYPE_DOUBLE
    )
    """Fuel consumption rate in liters per second."""


@dataclass(eq=False, repr=False)
class PrototypeExtensions(betterproto.Message):
    extensions: Dict[str, "betterproto_lib_google_protobuf.Any"] = (
        betterproto.map_field(1, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE)
    )


@dataclass(eq=False, repr=False)
class Signal(betterproto.Message):
    """A component that describes an entity's signal characteristics."""

    frequency_center: "Frequency" = betterproto.message_field(
        1, group="frequency_measurement"
    )
    frequency_range: "FrequencyRange" = betterproto.message_field(
        2, group="frequency_measurement"
    )
    bandwidth_hz: Optional[float] = betterproto.message_field(
        3, wraps=betterproto.TYPE_DOUBLE
    )
    """Indicates the bandwidth of a signal (Hz)."""

    signal_to_noise_ratio: Optional[float] = betterproto.message_field(
        4, wraps=betterproto.TYPE_DOUBLE
    )
    """Indicates the signal to noise (SNR) of this signal."""

    line_of_bearing: "LineOfBearing" = betterproto.message_field(5, group="report")
    fixed: "Fixed" = betterproto.message_field(6, group="report")
    emitter_notations: List["EmitterNotation"] = betterproto.message_field(7)
    """Emitter notations associated with this entity."""

    pulse_width_s: Optional[float] = betterproto.message_field(
        8, wraps=betterproto.TYPE_DOUBLE
    )
    """length in time of a single pulse"""

    pulse_repetition_interval: "PulseRepetitionInterval" = betterproto.message_field(9)
    """length in time between the start of two pulses"""

    modulation: "Modulation" = betterproto.message_field(10)
    """characteristics of the carrier signal to transmit information"""

    scan_characteristics: "ScanCharacteristics" = betterproto.message_field(11)
    """describes how a signal is observing the environment"""


@dataclass(eq=False, repr=False)
class EmitterNotation(betterproto.Message):
    """A representation of a single emitter notation."""

    emitter_notation: str = betterproto.string_field(1)
    confidence: Optional[float] = betterproto.message_field(
        2, wraps=betterproto.TYPE_DOUBLE
    )
    """
    confidence as a percentage that the emitter notation in this component is
    accurate
    """


@dataclass(eq=False, repr=False)
class Measurement(betterproto.Message):
    """A component that describes some measured value with error."""

    value: Optional[float] = betterproto.message_field(1, wraps=betterproto.TYPE_DOUBLE)
    """The value of the measurement."""

    sigma: Optional[float] = betterproto.message_field(2, wraps=betterproto.TYPE_DOUBLE)
    """Estimated one standard deviation in same unit as the value."""


@dataclass(eq=False, repr=False)
class Frequency(betterproto.Message):
    """A component for describing frequency."""

    frequency_hz: "Measurement" = betterproto.message_field(1)
    """Indicates a frequency of a signal (Hz) with its standard deviation."""


@dataclass(eq=False, repr=False)
class FrequencyRange(betterproto.Message):
    """A component to represent a frequency range."""

    minimum_frequency_hz: "Frequency" = betterproto.message_field(1)
    """Indicates the lowest measured frequency of a signal (Hz)."""

    maximum_frequency_hz: "Frequency" = betterproto.message_field(2)
    """Indicates the maximum measured frequency of a signal (Hz)."""


@dataclass(eq=False, repr=False)
class LineOfBearing(betterproto.Message):
    """A line of bearing of a signal."""

    origin: "Position" = betterproto.message_field(1)
    """
    `origin` and `range_bearing` have been deprecated in favor of
    `angle_of_arrival` The location of the asset at the time of measurement.
    """

    range_bearing: "RangeBearing" = betterproto.message_field(2)
    """Describes the horizontal angle with respect to true north."""

    angle_of_arrival: "AngleOfArrival" = betterproto.message_field(3)
    """The direction pointing from this entity to the detection"""

    range_estimate_m: "Measurement" = betterproto.message_field(
        4, group="detection_range"
    )
    """The estimated distance of the detection"""

    max_range_m: "Measurement" = betterproto.message_field(5, group="detection_range")
    """The maximum distance of the detection"""

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("origin"):
            warnings.warn("LineOfBearing.origin is deprecated", DeprecationWarning)
        if self.is_set("range_bearing"):
            warnings.warn(
                "LineOfBearing.range_bearing is deprecated", DeprecationWarning
            )


@dataclass(eq=False, repr=False)
class AngleOfArrival(betterproto.Message):
    """The direction from which the signal is received"""

    relative_pose: "__type__.Pose" = betterproto.message_field(1)
    """
    Origin (LLA) and attitude (relative to ENU) of a ray pointing towards the
    detection. The attitude represents a forward-left-up (FLU) frame where the
    x-axis (1, 0, 0) is pointing towards the target.
    """

    bearing_elevation_covariance_rad2: "__type__.TMat2" = betterproto.message_field(2)
    """
    Bearing/elevation covariance matrix where bearing is defined in radians
    CCW+ about the z-axis from the x-axis of FLU frame and elevation is
    positive down from the FL/XY plane. mxx = bearing variance in rad^2 mxy =
    bearing/elevation covariance in rad^2 myy = elevation variance in rad^2
    """


@dataclass(eq=False, repr=False)
class Fixed(betterproto.Message):
    """
    A fix of a signal. No extra fields but it is expected that location should
    be populated when using this report.
    """

    pass


@dataclass(eq=False, repr=False)
class RangeBearing(betterproto.Message):
    """
    Describes range and vertical and horizontal angular measurements of an
    entity with respect to a target.
    """

    range_m: "Measurement" = betterproto.message_field(1)
    """
    The range to a target along the measured angle in meters with its one sigma
    error value.
    """

    range_angle_d: "Measurement" = betterproto.message_field(2)
    """
    Horizontal angle - degrees rotated clockwise from origin_heading: 0-360.
    Sigma is the standard deviation of the horizontal angular measurement in
    decimal degrees: 0-180 degrees.
    """


@dataclass(eq=False, repr=False)
class PulseRepetitionInterval(betterproto.Message):
    """A component that describe the length in time between two pulses"""

    pulse_repetition_interval_s: "Measurement" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class Modulation(betterproto.Message):
    """
    A component that describe how information is encoded in a transmitted
    signal through a carrier signal
    """

    modulation_type: "ModulationType" = betterproto.enum_field(1)
    """Modifications to the carrier signal"""

    symbols: Optional[int] = betterproto.message_field(2, wraps=betterproto.TYPE_INT32)
    """
    describes the number of "symbols" that could be communicated with the
    modulation type if modulation type is ASK and symbol is 4, signal could
    have 1 of 4 different amplitudes.
    """

    interpulse_modulation: str = betterproto.string_field(3)
    """
    Variations in the time intervals between pulses and the spacing and number
    of pulses in a series
    """

    encoding: "Encoding" = betterproto.message_field(4)
    """
    describes how information is formatted within the signal during
    transmission
    """


@dataclass(eq=False, repr=False)
class Encoding(betterproto.Message):
    """
    A component that describes the formatting of the information in a signal
    """

    chip_hop_rate_num_sec: Optional[float] = betterproto.message_field(
        1, wraps=betterproto.TYPE_DOUBLE
    )
    """
    rate at which the spreading code is changing a chip is a pulse of a spread
    spectrum code. Each data bit is spread across multiple chips (smaller time
    slots) using a spreading code
    """

    hop_dwell_time_sec: Optional[float] = betterproto.message_field(
        2, wraps=betterproto.TYPE_DOUBLE
    )
    """
    time a transmitter remains at a particular frequency before hopping to the
    next on
    """

    baud_rate_num_sec: Optional[float] = betterproto.message_field(
        3, wraps=betterproto.TYPE_DOUBLE
    )
    """
    symbols per sec. A symbol is distinct from a bit where one symbol could be
    composed of multiple bits
    """


@dataclass(eq=False, repr=False)
class ScanCharacteristics(betterproto.Message):
    """A component that describes the scanning characteristics of a signal"""

    scan_type: "ScanType" = betterproto.enum_field(1)
    scan_period_s: Optional[float] = betterproto.message_field(
        2, wraps=betterproto.TYPE_DOUBLE
    )


@dataclass(eq=False, repr=False)
class Sensors(betterproto.Message):
    """List of sensors available for an entity."""

    sensors: List["Sensor"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class Sensor(betterproto.Message):
    """Individual sensor configuration."""

    sensor_id: str = betterproto.string_field(1)
    """
    This generally is used to indicate a specific type at a more detailed
    granularity. E.g. COMInt, LWIR or Echodyne
    """

    operational_state: "OperationalState" = betterproto.enum_field(3)
    field_of_view: "FieldOfView" = betterproto.message_field(4)
    """
    DEPRECATED -- use `fields_of_view` instead. This field will be marked
    deprecated and no longer populated by 11/26/2023.
    """

    sensor_type: "SensorType" = betterproto.enum_field(5)
    """The type of sensor"""

    sensor_description: str = betterproto.string_field(6)
    """A human readable description of the sensor"""

    rf_configuraton: "RfConfiguration" = betterproto.message_field(7)
    """RF configuration details of the sensor"""

    last_detection_timestamp: datetime = betterproto.message_field(8)
    """Time of the latest detection from the sensor"""

    fields_of_view: List["FieldOfView"] = betterproto.message_field(9)
    """Multiple fields of view for a single sensor component"""


@dataclass(eq=False, repr=False)
class FieldOfView(betterproto.Message):
    """Sensor Field Of View closely resembling fov.proto SensorFieldOfView."""

    fov_id: int = betterproto.int32_field(1)
    """
    The Id for one instance of a FieldOfView, persisted across multiple updates
    to provide continuity during smoothing. This is relevant for sensors like
    an ESM or Radar where the dwell schedule is on the order of milliseconds,
    making multiple FOVs a requirement for proper display of search and weapon
    support beams.
    """

    mount_id: str = betterproto.string_field(2)
    """The Id of the mount the sensor is on."""

    projected_frustum: "ProjectedFrustum" = betterproto.message_field(3)
    """The field of view the sensor projected onto the ground."""

    projected_center_ray: "Position" = betterproto.message_field(4)
    """Center ray of the frustum projected onto the ground."""

    center_ray_pose: "Pose" = betterproto.message_field(5)
    """
    The origin and direction of the center ray for this sensor relative to the
    ENU frame. A ray which is aligned with the positive X axis in the sensor
    frame will be transformed into the ray along the sensor direction in the
    ENU frame when transformed by the quaternion contained in this pose.
    """

    horizontal_fov: float = betterproto.float_field(6)
    """Horizontal field of view in radians."""

    vertical_fov: float = betterproto.float_field(7)
    """Vertical field of view in radians."""

    range: Optional[float] = betterproto.message_field(8, wraps=betterproto.TYPE_FLOAT)
    """Sensor range in meters."""

    mode: "SensorMode" = betterproto.enum_field(9)
    """
    The mode that this sensor is currently in, used to display for context in
    the UI. Some sensors can emit multiple sensor field of views with different
    modes, for example a radar can simultaneously search broadly and perform
    tighter bounded tracking.
    """


@dataclass(eq=False, repr=False)
class ProjectedFrustum(betterproto.Message):
    """
    Represents a frustum in which which all four corner points project onto the
    ground. All points in this message are optional, if the projection to the
    ground fails then they will not be populated.
    """

    upper_left: "Position" = betterproto.message_field(1)
    """Upper left point of the frustum."""

    upper_right: "Position" = betterproto.message_field(2)
    """Upper right point of the frustum."""

    bottom_right: "Position" = betterproto.message_field(3)
    """Bottom right point of the frustum."""

    bottom_left: "Position" = betterproto.message_field(4)
    """Bottom left point of the frustum."""


@dataclass(eq=False, repr=False)
class RfConfiguration(betterproto.Message):
    """Represents RF configurations supported on this sensor."""

    frequency_range: List["FloatRange"] = betterproto.message_field(1)
    """Frequency ranges that are available for this sensor."""

    bandwidth_range: List["FloatRange"] = betterproto.message_field(2)
    """Bandwidth ranges that are available for this sensor."""

    frequency_range_hz: List["FrequencyRange"] = betterproto.message_field(3)
    """Frequency ranges that are available for this sensor."""

    bandwidth_range_hz: List["BandwidthRange"] = betterproto.message_field(4)
    """Bandwidth ranges that are available for this sensor."""

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("frequency_range"):
            warnings.warn(
                "RfConfiguration.frequency_range is deprecated", DeprecationWarning
            )
        if self.is_set("bandwidth_range"):
            warnings.warn(
                "RfConfiguration.bandwidth_range is deprecated", DeprecationWarning
            )


@dataclass(eq=False, repr=False)
class BandwidthRange(betterproto.Message):
    """A component that describes the min and max bandwidths of a sensor"""

    minimum_bandwidth: "Bandwidth" = betterproto.message_field(1)
    maximum_bandwidth: "Bandwidth" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class Bandwidth(betterproto.Message):
    """Describes the bandwidth of a signal"""

    bandwidth_hz: Optional[float] = betterproto.message_field(
        1, wraps=betterproto.TYPE_DOUBLE
    )


@dataclass(eq=False, repr=False)
class Relationships(betterproto.Message):
    """
    The relationships between this entity and other entities in the
    battlespace.
    """

    relationships: List["Relationship"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class Relationship(betterproto.Message):
    """
    The relationship component indicates a relationship to another entity.
    """

    related_entity_id: str = betterproto.string_field(1)
    """The entity ID to which this entity is related."""

    relationship_id: str = betterproto.string_field(2)
    """
    A unique identifier for this relationship. Allows removing or updating
    relationships.
    """

    relationship_type: "RelationshipType" = betterproto.message_field(3)
    """The relationship type"""


@dataclass(eq=False, repr=False)
class RelationshipType(betterproto.Message):
    """Determines the type of relationship between this entity and another."""

    tether: "Tether" = betterproto.message_field(1, group="type")
    tracked_by: "TrackedBy" = betterproto.message_field(2, group="type")
    configure: "Configure" = betterproto.message_field(3, group="type")
    group_child: "GroupChild" = betterproto.message_field(4, group="type")
    group_parent: "GroupParent" = betterproto.message_field(5, group="type")
    merged_from: "MergedFrom" = betterproto.message_field(6, group="type")


@dataclass(eq=False, repr=False)
class Tether(betterproto.Message):
    """
    A tether relationship indicates that this entity should take the position
    of the other entity.
    """

    pass


@dataclass(eq=False, repr=False)
class TrackedBy(betterproto.Message):
    """
    Describes the relationship between the entity being tracked ("tracked
    entity") and the entity that is performing the tracking ("tracking
    entity").
    """

    actively_tracking_sensors: "Sensors" = betterproto.message_field(1)
    """
    Sensor details of the tracking entity's sensors that were active and
    tracking the tracked entity. This may be a subset of the total sensors
    available on the tracking entity.
    """

    last_measurement_timestamp: datetime = betterproto.message_field(2)
    """
    Latest time that any sensor in actively_tracking_sensors detected the
    tracked entity.
    """


@dataclass(eq=False, repr=False)
class Configure(betterproto.Message):
    """
    A configure relationship indicates that this entity is a configuration on
    other entity.
    """

    pass


@dataclass(eq=False, repr=False)
class GroupChild(betterproto.Message):
    """
    A GroupChild relationship is a uni-directional relationship indicating that
    (1) this entity represents an Entity Group and (2) the related entity is a
    child member of this group. The presence of this relationship alone
    determines that the type of group is an Entity Group.
    """

    pass


@dataclass(eq=False, repr=False)
class GroupParent(betterproto.Message):
    """
    A GroupParent relationship is a uni-directional relationship indicating
    that this entity is a member of the Entity Group represented by the related
    entity. The presence of this relationship alone determines that the type of
    group that this entity is a member of is an Entity Group.
    """

    pass


@dataclass(eq=False, repr=False)
class MergedFrom(betterproto.Message):
    """
    A MergedFrom relationship is a uni-directional relationship indicating that
    this entity is a merged entity whose data has at least partially been
    merged from the related entity.
    """

    pass


@dataclass(eq=False, repr=False)
class RouteDetails(betterproto.Message):
    destination_name: str = betterproto.string_field(1)
    """Free form text giving the name of the entity's destination"""

    estimated_arrival_time: datetime = betterproto.message_field(2)
    """Estimated time of arrival at destination"""


@dataclass(eq=False, repr=False)
class Schedules(betterproto.Message):
    """Schedules associated with this entity"""

    schedules: List["Schedule"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class Schedule(betterproto.Message):
    """A Schedule associated with this entity"""

    windows: List["CronWindow"] = betterproto.message_field(1)
    """expression that represents this schedule's "ON" state"""

    schedule_id: str = betterproto.string_field(2)
    """A unique identifier for this schedule."""

    schedule_type: "ScheduleType" = betterproto.enum_field(3)
    """The schedule type"""


@dataclass(eq=False, repr=False)
class CronWindow(betterproto.Message):
    cron_expression: str = betterproto.string_field(1)
    """
    in UTC, describes when and at what cadence this window starts, in the
    quartz flavor of cron examples:    This schedule is begins at 7:00:00am UTC
    everyday between Monday and Friday        0 0 7 ? * MON-FRI *    This
    schedule begins every 5 minutes starting at 12:00:00pm UTC until 8:00:00pm
    UTC everyday        0 0/5 12-20 * * ? *    This schedule begins at
    12:00:00pm UTC on March 2nd 2023        0 0 12 2 3 ? 2023 for more guidance
    see: http://www.quartz-
    scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html
    """

    duration_millis: int = betterproto.uint64_field(2)
    """describes the duration"""


@dataclass(eq=False, repr=False)
class Supplies(betterproto.Message):
    """
    Represents the state of supplies associated with an entity (available but
    not in condition to use immediately)
    """

    munitions: List["Munition"] = betterproto.message_field(1)
    fuel: List["Fuel"] = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class Munition(betterproto.Message):
    """
    Munition describes an entity's munitions stores of a similar condition,
    classification, and quantity
    """

    munition_id: str = betterproto.string_field(1)
    """
    unique munition identifier (for the DoD would be called a munition code.
    e.g., AGM-114 for the AGM-114 Hellfire missile) no "componentIdentifier"
    field option included. It may be possible munitions with the same
    identifier (e.g., AGM-114) but different condition codes or quantities
    (e.g., qty 4 in condition A but qty 2 in condition F) are included in the
    repeated munitions field of the supplies message.
    """

    name: str = betterproto.string_field(2)
    """long form name of the munition (e.g., AGM-114 Hellfire)"""

    dod_condition_code: "DodConditionCode" = betterproto.enum_field(
        3, group="condition"
    )
    """status of the munition (U.S. DoD Specific)"""

    quantity_units: int = betterproto.uint32_field(4)
    """number of units"""

    data_classification: "Classification" = betterproto.message_field(5)
    """
    munitions in a single asset may have different levels of classification use
    case: nukes on ballistic missile submarine may be TS/SCI while torpedoes
    may be SECRET
    """

    data_source: str = betterproto.string_field(6)
    """source of information"""


@dataclass(eq=False, repr=False)
class Fuel(betterproto.Message):
    """
    Fuel describes an entity's repository of fuels stores including current
    amount, operational requirements, and maximum authorized capacity
    """

    fuel_id: str = betterproto.string_field(1)
    """
    unique munition identifier (for the DoD would be called a munition code.
    e.g., AGM-114 for the AGM-114 Hellfire missile)
    """

    name: str = betterproto.string_field(2)
    """long form name of the munition (e.g., AGM-114 Hellfire)"""

    reported_date: datetime = betterproto.message_field(3)
    """timestamp the information was reported"""

    amount_gallons: int = betterproto.uint32_field(4)
    """amount on hand of the unit of measure"""

    max_authorized_capacity_gallons: int = betterproto.uint32_field(5)
    """how much the asset is allowed to have available (in gallons)"""

    operational_requirement_gallons: int = betterproto.uint32_field(6)
    """minimum required for operations (in gallons)"""

    data_classification: "Classification" = betterproto.message_field(7)
    """
    fuel in a single asset may have different levels of classification use
    case: fuel for a SECRET asset while diesel fuel may be UNCLASSIFIED
    """

    data_source: str = betterproto.string_field(8)
    """source of information"""


@dataclass(eq=False, repr=False)
class TargetPriority(betterproto.Message):
    """The target prioritization associated with an entity."""

    high_value_target: "HighValueTarget" = betterproto.message_field(1)
    """
    Describes the target priority in relation to high value target lists.
    """

    threat: "Threat" = betterproto.message_field(2)
    """Describes whether the entity should be treated as a threat"""


@dataclass(eq=False, repr=False)
class HighValueTarget(betterproto.Message):
    """Describes whether something is a high value target or not."""

    is_high_value_target: bool = betterproto.bool_field(1)
    """
    Indicates whether the target matches any description from a high value
    target list.
    """

    target_priority: int = betterproto.uint32_field(2)
    """
    The priority associated with the target. If the target's description
    appears on multiple high value target lists, the priority will be a
    reflection of the highest priority of all of those list's target
    description. A lower value indicates the target is of a higher priority,
    with 1 being the highest possible priority. A value of 0 indicates there is
    no priority associated with this target.
    """

    target_matches: List["HighValueTargetMatch"] = betterproto.message_field(3)
    """
    All of the high value target descriptions that the target matches against.
    """

    is_high_payoff_target: bool = betterproto.bool_field(4)
    """
    Indicates whether the target is a 'High Payoff Target'. Targets can be one
    or both of high value and high payoff. Semantically a High Value Target
    characterizes the target's importance to Red, whereas a High Payoff Target
    indicates prosecuting the target furthers Blue's specific objectives.
    """


@dataclass(eq=False, repr=False)
class HighValueTargetMatch(betterproto.Message):
    high_value_target_list_id: str = betterproto.string_field(1)
    """
    The ID of the high value target list that matches the target description.
    """

    high_value_target_description_id: str = betterproto.string_field(2)
    """
    The ID of the specific high value target description within a high value
    target list that was matched against. The ID is considered to be a globally
    unique identifier across all high value target IDs.
    """


@dataclass(eq=False, repr=False)
class Threat(betterproto.Message):
    """Describes whether an entity is a threat or not."""

    is_threat: bool = betterproto.bool_field(1)
    """Indicates that the entity has been determined to be a threat."""


@dataclass(eq=False, repr=False)
class TransponderCodes(betterproto.Message):
    """
    A message describing any transponder codes associated with Mode 1, 2, 3, 4,
    5, S interrogations.
    """

    mode1: int = betterproto.uint32_field(1)
    """
    The mode 1 code assigned to military assets. Mode 1 is a 5-bit decimal
    (1-31) value. Note that Mode 1 codes are NOT unique. A zero mode code
    indicates No Statement.
    """

    mode2: int = betterproto.uint32_field(2)
    """
    The Mode 2 code assigned to military assets. Mode 2 is a 12-bit decimal
    (1-4095) value. If displaying to a user, convert to 4 digit octal
    0001-7777. Note that Mode 2 codes are NOT unique. A zero mode code
    indicates No Statement.
    """

    mode3: int = betterproto.uint32_field(3)
    """
    The Mode 3 code assigned by ATC to the asset. Mode 3 is a 12-bit decimal
    (1-4095) value. If displaying to a user, convert to 4 digit octal
    0001-7777. Note that Mode 3 codes are NOT unique. A zero mode code
    indicates No Statement.
    """

    mode4_interrogation_response: "InterrogationResponse" = betterproto.enum_field(4)
    """The validity of the response from the Mode 4 interrogation."""

    mode5: "Mode5" = betterproto.message_field(5)
    """The Mode 5 transponder codes."""

    mode_s: "ModeS" = betterproto.message_field(6)
    """The Mode S transponder codes."""


@dataclass(eq=False, repr=False)
class Mode5(betterproto.Message):
    """Describes the Mode 5 transponder interrogation status and codes."""

    mode5_interrogation_response: "InterrogationResponse" = betterproto.enum_field(1)
    """The validity of the response from the Mode 5 interrogation."""

    mode5: int = betterproto.uint32_field(2)
    """
    The Mode 5 code assigned to military assets. Mode 5 is a 12-bit decimal
    (1-4095) value. If displaying to a user, convert to 4 digit octal
    0001-7777. Note that Mode 5 codes are NOT unique by themselves, but should
    be used in conjunction with the Mode 5 platform ID & nationality to provide
    unique identification. A zero mode code indicates No Statement.
    """

    mode5_platform_id: int = betterproto.uint32_field(3)
    """
    The Mode 5 platform identification code. Expected values are between 1 and
    16383. Used in conjunction with the Nationality it provides IFF/SIF
    capabilities. A zero platform id indicates No Statement.
    """


@dataclass(eq=False, repr=False)
class ModeS(betterproto.Message):
    """Describes the Mode S codes."""

    id: str = betterproto.string_field(1)
    """Mode S identifier which comprises of 8 alphanumeric characters."""

    address: int = betterproto.uint32_field(2)
    """
    The Mode S ICAO aircraft address. Expected values are between 1 and
    16777214 decimal. The Mode S address is considered unique.
    """


@dataclass(eq=False, repr=False)
class Entity(betterproto.Message):
    """
    An entity object represents a single entity within the Lattice operational
    environment, and it contains all data associated with that entity, such as
    its name, ID, and any other relevant components.
    """

    entity_id: str = betterproto.string_field(1)
    """
    A Globally Unique Identifier (GUID) for your entity. If blank, the Entity
    API creates an entity and automatically generates a new ID for the entity.
    """

    description: str = betterproto.string_field(2)
    """
    Helpful, human-readable entity description mainly used for debugging
    purposes and human traceability. If blank, the Entity API generates one for
    you.
    """

    is_live: bool = betterproto.bool_field(3)
    """
    Indicates an active asset receiving updates. This is a required field for
    publishing an entity. It needs to be set to true when publishing an entity.
    """

    created_time: datetime = betterproto.message_field(4)
    """
    Time when the asset enters the system. If blank, the Entity API uses a
    current timestamp. For example, when a drone is first powered on, it might
    report it's boot time as the created time.
    """

    expiry_time: datetime = betterproto.message_field(5)
    """
    A future time that expires an entity and updates the isLive flag. For
    entities that are constantly updating, the expiry time also updates. Note
    in some cases this may differ from isLive. Example: Entities with tasks
    exported to an external system must remain active, even after they expire.
    This is a required field for publishing an entity via Flux or
    PublishEntities rpc. When publishing an entity, this timestamp must be in
    the future, but less than 30 days from the current time.
    """

    no_expiry: bool = betterproto.bool_field(43)
    """
    To indicate that this entity should not expire. Only to be set to `true` on
    entities published via PutEntity call. Entities published via Flux or
    PublishEntities rpc with `no_expiry == true` will be rejected.
    """

    status: "Status" = betterproto.message_field(19)
    """Human-readable descriptions of what the entity is currently doing."""

    location: "Location" = betterproto.message_field(6)
    """
    Geospatial data related to the entity, including it's position, kinematics
    and orientation.
    """

    location_uncertainty: "LocationUncertainty" = betterproto.message_field(15)
    """Uncertainty of the entity's position and kinematics."""

    geopolygon: "GeoPolygon" = betterproto.message_field(17)
    """Deprecated: do not use, use geo_shape instead"""

    geo_shape: "GeoShape" = betterproto.message_field(23)
    """
    Geospatial representation of the entity, including entities that cover an
    area rather than a fixed point.
    """

    geo_details: "GeoDetails" = betterproto.message_field(24)
    """
    Additional details on what the geospatial area or point represents, along
    with visual display details.
    """

    aliases: "Aliases" = betterproto.message_field(7)
    """
    Naming of the entity as well as identifiers that other systems use to
    reference the same entity.
    """

    tracked: "Tracked" = betterproto.message_field(8)
    """
    If this entity is tracked by another, this component contains data related
    to how it's being tracked.
    """

    correlated: "Correlated" = betterproto.message_field(9)
    """
    If this entity has been correlated to another one, this component contains
    the status of the correlation, the primary entity and the correlation
    scores.
    """

    mil_view: "MilView" = betterproto.message_field(10)
    """Military view of the entity"""

    ontology: "Ontology" = betterproto.message_field(11)
    """A standardized representation of the entity"""

    sensors: "Sensors" = betterproto.message_field(20)
    """Details of Sensors that are available on an entity"""

    payloads: "Payloads" = betterproto.message_field(21)
    """Details of payloads that are available on an entity"""

    power_state: "PowerState" = betterproto.message_field(30)
    """Details of the power source on an entity"""

    provenance: "Provenance" = betterproto.message_field(12)
    """The primary data source provenance for this entity"""

    overrides: "Overrides" = betterproto.message_field(13)
    """Provenance of override data"""

    indicators: "Indicators" = betterproto.message_field(14)
    """
    Indicators of an entity's state that describes properties of the entity as
    well as what operations can be performed on the entity (eg. can it be
    deleted)
    """

    original_data: "OriginalData" = betterproto.message_field(18)
    """
    A component that references the primary original data source. For example,
    this would allow the original NITF file data that was ingested to be
    retrieved.
    """

    target_priority: "TargetPriority" = betterproto.message_field(22)
    """
    The prioritization associated with an entity such as if it's a threat or a
    high value target.
    """

    signal: "Signal" = betterproto.message_field(25)
    """
    A component that describes an entity's signal characteristics. Primarily
    used if the entity is a signal of interest
    """

    transponder_codes: "TransponderCodes" = betterproto.message_field(26)
    """
    A message describing any transponder codes associated with Mode 1, 2, 3, 4,
    5, S interrogations. These are related to ADS-B modes
    """

    contact: "ContactDetails" = betterproto.message_field(27)
    """
    Contains details on how to make out-of-band contact with an entity, such as
    via a phone or email
    """

    data_classification: "Classification" = betterproto.message_field(29)
    """
    A component that describes an entity's security classification levels both
    at an overall classification level for the entity as well as on a per field
    level.
    """

    task_catalog: "__tasks_v2__.TaskCatalog" = betterproto.message_field(31)
    """A catalog of tasks that can be performed by an entity."""

    media: "Media" = betterproto.message_field(32)
    """
    Media associated with an entity such as videos, images or thumbnails.
    """

    relationships: "Relationships" = betterproto.message_field(33)
    """
    The relationships between this entity and other entities in the
    battlespace.
    """

    visual_details: "VisualDetails" = betterproto.message_field(34)
    """
    Visual details associated with the display of an entity in the client.
    """

    prototype_extensions: "PrototypeExtensions" = betterproto.message_field(35)
    """
    A generic component that should only be used by Anduril employees as a way
    of ferrying data without modelling it as a full component. USE WITH
    CAUTION!!The following should be considered before use: If you have the
    time available, liaise with the battlespace team (#battlespace-team) to
    determine if this should be modelled on an existing/new component You're
    responsible for handling key conflicts Any data on here is not supported by
    the battlespace awareness team The intention is for this to be used by
    short-lived prototypes where you may not have conviction in it's longevity
    🙏
    """

    dimensions: "Dimensions" = betterproto.message_field(36)
    """Physical dimensions of the entity"""

    route_details: "RouteDetails" = betterproto.message_field(37)
    """Additional information about an entity's route."""

    schedules: "Schedules" = betterproto.message_field(38)
    """Schedules associated with this entity"""

    health: "Health" = betterproto.message_field(39)
    """Health metrics or status reported by the entity"""

    group_details: "GroupDetails" = betterproto.message_field(40)
    """Details for the group associated with this entity"""

    team_status: "TeamStatus" = betterproto.message_field(41)
    """
    Describes an entity's collaborative autonomous teaming status, if any.
    """

    supplies: "Supplies" = betterproto.message_field(42)
    """
    Contains relevant supply information for the entity (e.g., munitions and
    fuel)
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("geopolygon"):
            warnings.warn("Entity.geopolygon is deprecated", DeprecationWarning)


@dataclass(eq=False, repr=False)
class Entities(betterproto.Message):
    """
    We need a proto containing a list of Entities for marshalling/unmarshalling
    """

    entities: List["Entity"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class Status(betterproto.Message):
    """Contains status of entities."""

    platform_activity: str = betterproto.string_field(1)
    """
    A string that describes the activity that the entity is performing. These
    values include, but are not limited to the
    AIR/SURFACE/SUBSURFACE/LAND/SPACE ACTIVITY values found in MIL-STD 6016F.
    Examples include "RECONNAISSANCE", "INTERDICTION", "ELECTRONIC WARFARE
    (EW)", "RETURN TO BASE (RTB)", "PREPARING FOR LAUNCH".
    """

    role: str = betterproto.string_field(2)
    """
    A string that describes the role the entity is currently performing. E.g.
    "Team Member", "Commander" or
    """


@dataclass(eq=False, repr=False)
class Aliases(betterproto.Message):
    """Available for any Entities with alternate ids in other systems."""

    alternate_ids: List["AlternateId"] = betterproto.message_field(1)
    name: str = betterproto.string_field(2)
    """The best available version of the entity's display name."""


@dataclass(eq=False, repr=False)
class Tracked(betterproto.Message):
    """Available for Entities that are tracked."""

    track_quality: int = betterproto.uint32_field(1)
    """
    deprecated in favor of track_quality_wrapper to better indicate when TQ is
    actually missing vs 0 which is valid
    """

    track_quality_wrapper: Optional[int] = betterproto.message_field(
        2, wraps=betterproto.TYPE_INT32
    )
    """Quality score, 0-15, nil if none"""

    sensor_hits: Optional[int] = betterproto.message_field(
        3, wraps=betterproto.TYPE_INT32
    )
    """Sensor hits aggregation on the tracked entity."""

    number_of_objects: "UInt32Range" = betterproto.message_field(4)
    """
    Estimated number of objects or units that are represented by this entity.
    Known as Strength in certain contexts (Link16) if UpperBound == LowerBound;
    (strength = LowerBound) If both UpperBound and LowerBound are defined;
    strength is between LowerBound and UpperBound (represented as string
    "Strength: 4-5") If UpperBound is defined only (LowerBound unset), Strength
    ≤ UpperBound If LowerBound is defined only (UpperBound unset), LowerBound ≤
    Strength 0 indicates unset.
    """

    sensor_details: "Sensors" = betterproto.message_field(5)
    """
    deprecated. data from sensors actively tracking the entity are placed in
    the TrackedBy relationship.
    """

    radar_cross_section: Optional[float] = betterproto.message_field(
        6, wraps=betterproto.TYPE_DOUBLE
    )
    """
    The radar cross section (RCS) is a measure of how detectable an object is
    by radar. A large RCS indicates an object is more easily detected. The unit
    is “decibels per square meter,” or dBsm
    """

    last_measurement_time: datetime = betterproto.message_field(7)
    """Timestamp of the latest tracking measurement for this entity."""

    line_of_bearing: "LineOfBearing" = betterproto.message_field(9)
    """
    The relative position of a track with respect to the entity that is
    tracking it. Used for tracks that do not yet have a 3D position. For this
    entity (A), being tracked by some entity (B), this LineOfBearing would
    express a ray from B to A.
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("track_quality"):
            warnings.warn("Tracked.track_quality is deprecated", DeprecationWarning)
        if self.is_set("sensor_details"):
            warnings.warn("Tracked.sensor_details is deprecated", DeprecationWarning)


@dataclass(eq=False, repr=False)
class Provenance(betterproto.Message):
    """Data provenance."""

    integration_name: str = betterproto.string_field(5)
    """Name of the integration that produced this entity"""

    data_type: str = betterproto.string_field(6)
    """Source data type of this entity. Examples: ADSB, Link16, etc."""

    source: "Source" = betterproto.enum_field(1)
    """Enum defining the source TO BE DEPRECATED"""

    source_id: str = betterproto.string_field(3)
    """An ID that allows an element from a source to be uniquely identified"""

    source_update_time: datetime = betterproto.message_field(2)
    """Main update timer for the entity with the exception of overrides"""

    source_description: str = betterproto.string_field(4)
    """
    Description of the modification source. In the case of a user this is the
    email address.
    """


@dataclass(eq=False, repr=False)
class Indicators(betterproto.Message):
    """Indicators to describe entity to consumers."""

    simulated: Optional[bool] = betterproto.message_field(
        1, wraps=betterproto.TYPE_BOOL
    )
    exercise: Optional[bool] = betterproto.message_field(2, wraps=betterproto.TYPE_BOOL)
    emergency: Optional[bool] = betterproto.message_field(
        3, wraps=betterproto.TYPE_BOOL
    )
    c2: Optional[bool] = betterproto.message_field(4, wraps=betterproto.TYPE_BOOL)
    deletable: "Deletable" = betterproto.enum_field(5)
    egressable: Optional[bool] = betterproto.message_field(
        6, wraps=betterproto.TYPE_BOOL
    )
    """
    Indicates the Entity should be egressed to external sources. Integrations
    choose how the egressing happens (e.g. if an Entity needs fuzzing).
    """

    starred: Optional[bool] = betterproto.message_field(7, wraps=betterproto.TYPE_BOOL)
    """
    A signal of arbitrary importance such that the entity should be globally
    marked for all users
    """


@dataclass(eq=False, repr=False)
class Overrides(betterproto.Message):
    """Metadata about entity overrides present."""

    override: List["Override"] = betterproto.message_field(2)
    provenance: List["OverrideProvenance"] = betterproto.message_field(1)
    """Deprecated: do not use"""

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("provenance"):
            warnings.warn("Overrides.provenance is deprecated", DeprecationWarning)


@dataclass(eq=False, repr=False)
class Override(betterproto.Message):
    """Details about an override. Last write wins."""

    request_id: str = betterproto.string_field(1)
    """override request id for an override request"""

    field_path: str = betterproto.string_field(2)
    """
    proto field path which is the string representation of a field. example:
    correlated.primary_entity_id would be primary_entity_id in correlated
    component
    """

    masked_field_value: "Entity" = betterproto.message_field(3)
    """
    new field value corresponding to field path. In the shape of an empty
    entity with only the changed value. example: entity: { mil_view: {
    disposition: Disposition_DISPOSITION_HOSTILE } }
    """

    status: "OverrideStatus" = betterproto.enum_field(4)
    """status of the override"""

    provenance: "Provenance" = betterproto.message_field(5)
    type: "OverrideType" = betterproto.enum_field(6)
    """
    The type of the override, defined by the stage of the entity lifecycle that
    the entity was in when the override was requested.
    """

    request_timestamp: datetime = betterproto.message_field(7)
    """
    Timestamp of the override request. The timestamp is generated by the Entity
    Manager instance that receives the request.
    """


@dataclass(eq=False, repr=False)
class OverrideProvenance(betterproto.Message):
    """The provenance of a particular override within the entity."""

    field_path: str = betterproto.string_field(1)
    """
    proto field path which is the string representation of a field. example:
    correlated.primary_entity_id would be primary_entity_id in correlated
    component
    """

    source_id: str = betterproto.string_field(2)
    """Deprecated: do not use"""

    provenance: "Provenance" = betterproto.message_field(3)

    def __post_init__(self) -> None:
        warnings.warn("OverrideProvenance is deprecated", DeprecationWarning)
        super().__post_init__()
        if self.is_set("source_id"):
            warnings.warn(
                "OverrideProvenance.source_id is deprecated", DeprecationWarning
            )


@dataclass(eq=False, repr=False)
class OriginalData(betterproto.Message):
    """
    A component that references the primary original data source. For example,
    this would allow the original NITF file data that was ingested to be
    retrieved.
    """

    url: str = betterproto.string_field(1)
    """
    The URL is a reference to the data's location so it can be retrieved after
    being converted to an entity.
    """

    tle: "OriginalDataTle" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class OriginalDataTle(betterproto.Message):
    """
    A TLE is a space industry standard for representing the characteristics of
    an object on orbit. It is composed of two lines that are each a fixed width
    of 69 characters.
    """

    line1: str = betterproto.string_field(1)
    line2: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class AlternateId(betterproto.Message):
    """An alternate id for an Entity."""

    source: str = betterproto.string_field(1)
    """deprecated in favor of type"""

    id: str = betterproto.string_field(2)
    type: "AltIdType" = betterproto.enum_field(3)

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("source"):
            warnings.warn("AlternateId.source is deprecated", DeprecationWarning)


@dataclass(eq=False, repr=False)
class VisualDetails(betterproto.Message):
    """
    Visual details associated with the display of an entity in the client.
    """

    range_rings: "RangeRings" = betterproto.message_field(1)
    """The range rings to display around an entity."""

    interactivity_mode: "InteractivityMode" = betterproto.enum_field(2)
    """
    Control the operator's ability to interact with the entity on the UI
    (disable hover/click on map, etc.) Not a security/access flag
    """


@dataclass(eq=False, repr=False)
class RangeRings(betterproto.Message):
    """
    Range rings allow visual assessment of map distance at varying zoom levels.
    """

    min_distance_m: Optional[float] = betterproto.message_field(
        1, wraps=betterproto.TYPE_DOUBLE
    )
    """The minimum range ring distance, specified in meters."""

    max_distance_m: Optional[float] = betterproto.message_field(
        2, wraps=betterproto.TYPE_DOUBLE
    )
    """The maximum range ring distance, specified in meters."""

    ring_count: int = betterproto.uint32_field(3)
    """The count of range rings."""


@dataclass(eq=False, repr=False)
class TeamStatus(betterproto.Message):
    """
    If present, signifies the entity can participate in collaborative
    autonomous teaming. Any status about team membership will be reported here.
    """

    pass


@dataclass(eq=False, repr=False)
class RateLimit(betterproto.Message):
    """rate-limiting / down-sampling parameters."""

    update_per_entity_limit_ms: int = betterproto.uint32_field(1)
    """
    Specifies a minimum duration in milliseconds after an update for a given
    entity before another one will be sent for the same entity. A value of 0 is
    treated as unset. If set, value must be >= 500. Example: if set to 1000,
    and 4 events occur (ms since start) at T0, T500, T900, T2100, then event
    from T0 will be sent at T0, T500 will be dropped, T900 will be sent at
    minimum of T1000, and T2100 will be sent on time (2100) This will only
    limit updates, other events will be sent immediately, with a delete
    clearing anything held
    """


@dataclass(eq=False, repr=False)
class GetEntityRequest(betterproto.Message):
    entity_id: str = betterproto.string_field(1)
    """the GUID of this entity to query"""


@dataclass(eq=False, repr=False)
class GetEntityResponse(betterproto.Message):
    entity: "Entity" = betterproto.message_field(1)
    """an Entity object that corresponds with the requested entityId"""


@dataclass(eq=False, repr=False)
class StreamEntityComponentsRequest(betterproto.Message):
    components_to_include: List[str] = betterproto.string_field(1)
    """
    lower_snake_cased component names to include in response events, e.g.
    location. Only included components will populate.
    """

    include_all_components: bool = betterproto.bool_field(2)
    """
    subscribe to all components. This should only be used in cases where you
    want all components (e.g. latticectl) and if you're using it for other
    services please reach out first. Setting both components_to_include and
    include_all_components is invalid and will be rejected.
    """

    filter: "Statement" = betterproto.message_field(3)
    """
    The root node of a statement filter "tree". If provided, only entities
    matching the filter criteria will be streamed. The filter is applied
    dynamically so if a new entity matches, it will be included, and if an
    entity updates to no longer match, it will be excluded.
    """

    rate_limit: "RateLimit" = betterproto.message_field(4)
    """
    optional rate-limiting / down-sampling parameters, see RateLimit message
    for details.
    """

    heartbeat_period_millis: int = betterproto.uint32_field(5)
    """
    The period (in milliseconds) at which a Heartbeat message will be sent on
    the message stream. If this field is set to 0 then no Heartbeat messages
    are sent.
    """

    preexisting_only: bool = betterproto.bool_field(6)
    """
    subscribe to a finite stream of preexisting events which closes when there
    are no additional pre-existing events to process. Respects the filter
    specified on the StreamEntityComponentsRequest.
    """


@dataclass(eq=False, repr=False)
class StreamEntityComponentsResponse(betterproto.Message):
    """
    response stream will be fed all matching pre-existing live entities as
    CREATED, plus any new events ongoing.
    """

    entity_event: "EntityEvent" = betterproto.message_field(1)
    heartbeat: "Heartbeat" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class PutEntityRequest(betterproto.Message):
    entity: "Entity" = betterproto.message_field(1)
    """
    The entity to put. Required fields:   * expiry_time - must be in the
    future, but less than 30 days from now   * provenance.data_type   *
    provenance.source_update_time (can be earlier than rpc call if data entered
    is older)   * aliases.name   * ontology.template any additional required
    fields will be determined by template, see
    com.anduril.entitymanager.v1.Template if an entity_id is provided, will
    treat as update, otherwise create
    """

    unique_id: str = betterproto.string_field(2)
    """
    An optional unique identifier for this entity supplied by integration. If
    provided, EntityId will be determined via consistent hash with
    provenance.data_type + unique_id
    """


@dataclass(eq=False, repr=False)
class PutEntityResponse(betterproto.Message):
    entity: "Entity" = betterproto.message_field(1)
    """
    The updated entity. Automatically updated fields:   * is_live - always
    reset to true   * entity_id - new GUID on create   * created_time - set on
    create
    """


@dataclass(eq=False, repr=False)
class PublishEntitiesRequest(betterproto.Message):
    entity: "Entity" = betterproto.message_field(1)
    """
    Stream of fully formed entities to publish Required fields per entity:   *
    expiry_time - must be in the future, but less than 30 days from now   *
    provenance.data_type   * provenance.source_update_time (can be earlier than
    rpc call if data entered is older)   * aliases.name   * ontology.template
    any additional required fields will be determined by template, see
    com.anduril.entitymanager.v1.Template if an entity_id is provided, will
    treat as update, otherwise create
    """


@dataclass(eq=False, repr=False)
class PublishEntitiesResponse(betterproto.Message):
    """
    After the stream is closed the server will return an empty message
    indicating success. If any streamed message caused an error then the stream
    is immediately terminated and an error code is returned.
    """

    pass


@dataclass(eq=False, repr=False)
class OverrideEntityRequest(betterproto.Message):
    entity: "Entity" = betterproto.message_field(1)
    """
    The entity containing the overwritten fields. The service will extract the
    overridable fields from the entity object and ignore any other fields.
    """

    field_path: List[str] = betterproto.string_field(2)
    """
    The field paths that will be extracted from the Entity and saved as an
    override. Only fields marked overridable can be overriden.
    """

    provenance: "Provenance" = betterproto.message_field(3)
    """Additional information about the source of the override"""


@dataclass(eq=False, repr=False)
class OverrideEntityResponse(betterproto.Message):
    status: "OverrideStatus" = betterproto.enum_field(1)
    """The status of the override request."""


@dataclass(eq=False, repr=False)
class RemoveEntityOverrideRequest(betterproto.Message):
    entity_id: str = betterproto.string_field(1)
    """The entity ID that the override will be removed from"""

    field_path: List[str] = betterproto.string_field(2)
    """
    The field paths to remove from the override store for the provided
    entityId.
    """


@dataclass(eq=False, repr=False)
class RemoveEntityOverrideResponse(betterproto.Message):
    """void response but with placeholder for future optional fields."""

    pass


@dataclass(eq=False, repr=False)
class DeleteEntityRequest(betterproto.Message):
    entity_id: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class DeleteEntityResponse(betterproto.Message):
    """void response but with placeholder for future optional fields."""

    pass


@dataclass(eq=False, repr=False)
class EntityEvent(betterproto.Message):
    """Event representing some type of entity change."""

    event_type: "EventType" = betterproto.enum_field(1)
    time: datetime = betterproto.message_field(2)
    entity: "Entity" = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class Heartbeat(betterproto.Message):
    """
    A message that is periodically sent on the stream for keep-alive behaviour.
    """

    timestamp: datetime = betterproto.message_field(1)
    """The timestamp at which the heartbeat message was sent."""


@dataclass(eq=False, repr=False)
class OverrideNotificationPayload(betterproto.Message):
    """A notification to indicate when a field is overridden on an entity."""

    entity: "Entity" = betterproto.message_field(1)
    """
    The entity containing the values to override and the entityID being
    overriden. Used by the client to determine the value a field is overridden
    to (e.g. hostile).
    """

    field_path: str = betterproto.string_field(2)
    """
    The field path determining the path on an entity to override. Used by the
    client to determine whether an override request was for a particular field
    (e.g. disposition).
    """

    provenance: "Provenance" = betterproto.message_field(3)
    """
    The provenance of the override request. This should always match the
    OverrideEntityRequest provenance field.
    """


class EntityManagerApiStub(betterproto.ServiceStub):
    async def get_entity(
        self,
        get_entity_request: "GetEntityRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetEntityResponse":
        return await self._unary_unary(
            "/anduril.entitymanager.v1.EntityManagerAPI/GetEntity",
            get_entity_request,
            GetEntityResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def stream_entity_components(
        self,
        stream_entity_components_request: "StreamEntityComponentsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["StreamEntityComponentsResponse"]:
        async for response in self._unary_stream(
            "/anduril.entitymanager.v1.EntityManagerAPI/StreamEntityComponents",
            stream_entity_components_request,
            StreamEntityComponentsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def put_entity(
        self,
        put_entity_request: "PutEntityRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "PutEntityResponse":
        return await self._unary_unary(
            "/anduril.entitymanager.v1.EntityManagerAPI/PutEntity",
            put_entity_request,
            PutEntityResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def publish_entities(
        self,
        publish_entities_request_iterator: Union[
            AsyncIterable["PublishEntitiesRequest"], Iterable["PublishEntitiesRequest"]
        ],
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "PublishEntitiesResponse":
        return await self._stream_unary(
            "/anduril.entitymanager.v1.EntityManagerAPI/PublishEntities",
            publish_entities_request_iterator,
            PublishEntitiesRequest,
            PublishEntitiesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def override_entity(
        self,
        override_entity_request: "OverrideEntityRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "OverrideEntityResponse":
        return await self._unary_unary(
            "/anduril.entitymanager.v1.EntityManagerAPI/OverrideEntity",
            override_entity_request,
            OverrideEntityResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def remove_entity_override(
        self,
        remove_entity_override_request: "RemoveEntityOverrideRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "RemoveEntityOverrideResponse":
        return await self._unary_unary(
            "/anduril.entitymanager.v1.EntityManagerAPI/RemoveEntityOverride",
            remove_entity_override_request,
            RemoveEntityOverrideResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete_entity(
        self,
        delete_entity_request: "DeleteEntityRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeleteEntityResponse":
        return await self._unary_unary(
            "/anduril.entitymanager.v1.EntityManagerAPI/DeleteEntity",
            delete_entity_request,
            DeleteEntityResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class EntityManagerApiBase(ServiceBase):

    async def get_entity(
        self, get_entity_request: "GetEntityRequest"
    ) -> "GetEntityResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def stream_entity_components(
        self, stream_entity_components_request: "StreamEntityComponentsRequest"
    ) -> AsyncIterator["StreamEntityComponentsResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield StreamEntityComponentsResponse()

    async def put_entity(
        self, put_entity_request: "PutEntityRequest"
    ) -> "PutEntityResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def publish_entities(
        self, publish_entities_request_iterator: AsyncIterator["PublishEntitiesRequest"]
    ) -> "PublishEntitiesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def override_entity(
        self, override_entity_request: "OverrideEntityRequest"
    ) -> "OverrideEntityResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def remove_entity_override(
        self, remove_entity_override_request: "RemoveEntityOverrideRequest"
    ) -> "RemoveEntityOverrideResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_entity(
        self, delete_entity_request: "DeleteEntityRequest"
    ) -> "DeleteEntityResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_entity(
        self, stream: "grpclib.server.Stream[GetEntityRequest, GetEntityResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_entity(request)
        await stream.send_message(response)

    async def __rpc_stream_entity_components(
        self,
        stream: "grpclib.server.Stream[StreamEntityComponentsRequest, StreamEntityComponentsResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.stream_entity_components,
            stream,
            request,
        )

    async def __rpc_put_entity(
        self, stream: "grpclib.server.Stream[PutEntityRequest, PutEntityResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.put_entity(request)
        await stream.send_message(response)

    async def __rpc_publish_entities(
        self,
        stream: "grpclib.server.Stream[PublishEntitiesRequest, PublishEntitiesResponse]",
    ) -> None:
        request = stream.__aiter__()
        response = await self.publish_entities(request)
        await stream.send_message(response)

    async def __rpc_override_entity(
        self,
        stream: "grpclib.server.Stream[OverrideEntityRequest, OverrideEntityResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.override_entity(request)
        await stream.send_message(response)

    async def __rpc_remove_entity_override(
        self,
        stream: "grpclib.server.Stream[RemoveEntityOverrideRequest, RemoveEntityOverrideResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.remove_entity_override(request)
        await stream.send_message(response)

    async def __rpc_delete_entity(
        self, stream: "grpclib.server.Stream[DeleteEntityRequest, DeleteEntityResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete_entity(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/anduril.entitymanager.v1.EntityManagerAPI/GetEntity": grpclib.const.Handler(
                self.__rpc_get_entity,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetEntityRequest,
                GetEntityResponse,
            ),
            "/anduril.entitymanager.v1.EntityManagerAPI/StreamEntityComponents": grpclib.const.Handler(
                self.__rpc_stream_entity_components,
                grpclib.const.Cardinality.UNARY_STREAM,
                StreamEntityComponentsRequest,
                StreamEntityComponentsResponse,
            ),
            "/anduril.entitymanager.v1.EntityManagerAPI/PutEntity": grpclib.const.Handler(
                self.__rpc_put_entity,
                grpclib.const.Cardinality.UNARY_UNARY,
                PutEntityRequest,
                PutEntityResponse,
            ),
            "/anduril.entitymanager.v1.EntityManagerAPI/PublishEntities": grpclib.const.Handler(
                self.__rpc_publish_entities,
                grpclib.const.Cardinality.STREAM_UNARY,
                PublishEntitiesRequest,
                PublishEntitiesResponse,
            ),
            "/anduril.entitymanager.v1.EntityManagerAPI/OverrideEntity": grpclib.const.Handler(
                self.__rpc_override_entity,
                grpclib.const.Cardinality.UNARY_UNARY,
                OverrideEntityRequest,
                OverrideEntityResponse,
            ),
            "/anduril.entitymanager.v1.EntityManagerAPI/RemoveEntityOverride": grpclib.const.Handler(
                self.__rpc_remove_entity_override,
                grpclib.const.Cardinality.UNARY_UNARY,
                RemoveEntityOverrideRequest,
                RemoveEntityOverrideResponse,
            ),
            "/anduril.entitymanager.v1.EntityManagerAPI/DeleteEntity": grpclib.const.Handler(
                self.__rpc_delete_entity,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeleteEntityRequest,
                DeleteEntityResponse,
            ),
        }
