# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: anduril/auth/v2/idp.pub.proto, anduril/auth/v2/tokens.pub.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from datetime import timedelta
from typing import (
    TYPE_CHECKING,
    Dict,
    List,
    Optional,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


@dataclass(eq=False, repr=False)
class GetSsourlRequest(betterproto.Message):
    email: str = betterproto.string_field(1)
    """The email address of the user wishing to authenticate."""

    redirect_url: str = betterproto.string_field(2)
    """
    The URL that the user should be redirected to after they successfully
    authenticate.
    """

    append_token: bool = betterproto.bool_field(3)
    """
    If true, appends the token to the query params when redirecting to
    redirect_url. Only for OIDC.
    """


@dataclass(eq=False, repr=False)
class GetSsourlResponse(betterproto.Message):
    invalid_email: "GetSsourlResponseInvalidEmail" = betterproto.message_field(
        1, group="response"
    )
    valid_domain: "GetSsourlResponseValidDomain" = betterproto.message_field(
        2, group="response"
    )


@dataclass(eq=False, repr=False)
class GetSsourlResponseInvalidEmail(betterproto.Message):
    """The given email was invalid or not registered."""

    reason: str = betterproto.string_field(1)
    """A human-readable reason (that may be shown to the user)."""


@dataclass(eq=False, repr=False)
class GetSsourlResponseValidDomain(betterproto.Message):
    """
    The given email domain is recognized, and the user may sign in using the
    specified IDPs.
    """

    idps: List["Idp"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class Idp(betterproto.Message):
    """A wrapper around the types of supported IDPs."""

    internal: "InternalIdp" = betterproto.message_field(1, group="idp")
    external: "ExternalIdp" = betterproto.message_field(2, group="idp")
    piv: "Piv" = betterproto.message_field(3, group="idp")


@dataclass(eq=False, repr=False)
class InternalIdp(betterproto.Message):
    """A message indicating that the user may login with the internal IDP."""

    pass


@dataclass(eq=False, repr=False)
class ExternalIdp(betterproto.Message):
    """A message indicating that a user may login with an external IDP."""

    name: str = betterproto.string_field(1)
    """A human-readable name for the IDP."""

    sso_url: str = betterproto.string_field(2)
    """
    The single sign on URL that the user may be redirected to to authenticate.
    """

    unique_id: str = betterproto.string_field(3)
    """
    String that uniquely identified the same IDP across different instances
    """


@dataclass(eq=False, repr=False)
class Piv(betterproto.Message):
    """
    A message indicating that the user may login using their PIV smart card.
    """

    pass


@dataclass(eq=False, repr=False)
class RefreshOidcTokensRequest(betterproto.Message):
    refresh_token: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class RefreshOidcTokensResponse(betterproto.Message):
    token_validity_duration: timedelta = betterproto.message_field(1)
    """
    The length of time that the token is valid for. User agents must refresh
    the user's token within this time period.
    """

    refresh_token: str = betterproto.string_field(2)
    id_token: str = betterproto.string_field(3)


class IdpsStub(betterproto.ServiceStub):
    async def get_ssourl(
        self,
        get_ssourl_request: "GetSsourlRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetSsourlResponse":
        return await self._unary_unary(
            "/anduril.auth.v2.Idps/GetSSOURL",
            get_ssourl_request,
            GetSsourlResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class TokensStub(betterproto.ServiceStub):
    async def refresh_oidc_tokens(
        self,
        refresh_oidc_tokens_request: "RefreshOidcTokensRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "RefreshOidcTokensResponse":
        return await self._unary_unary(
            "/anduril.auth.v2.Tokens/RefreshOidcTokens",
            refresh_oidc_tokens_request,
            RefreshOidcTokensResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class IdpsBase(ServiceBase):

    async def get_ssourl(
        self, get_ssourl_request: "GetSsourlRequest"
    ) -> "GetSsourlResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_ssourl(
        self, stream: "grpclib.server.Stream[GetSsourlRequest, GetSsourlResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_ssourl(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/anduril.auth.v2.Idps/GetSSOURL": grpclib.const.Handler(
                self.__rpc_get_ssourl,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetSsourlRequest,
                GetSsourlResponse,
            ),
        }


class TokensBase(ServiceBase):

    async def refresh_oidc_tokens(
        self, refresh_oidc_tokens_request: "RefreshOidcTokensRequest"
    ) -> "RefreshOidcTokensResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_refresh_oidc_tokens(
        self,
        stream: "grpclib.server.Stream[RefreshOidcTokensRequest, RefreshOidcTokensResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.refresh_oidc_tokens(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/anduril.auth.v2.Tokens/RefreshOidcTokens": grpclib.const.Handler(
                self.__rpc_refresh_oidc_tokens,
                grpclib.const.Cardinality.UNARY_UNARY,
                RefreshOidcTokensRequest,
                RefreshOidcTokensResponse,
            ),
        }
