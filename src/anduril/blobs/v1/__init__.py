# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: anduril/blobs/v1/blobs_api.pub.proto, anduril/blobs/v1/common.pub.proto, anduril/blobs/v1/filter.pub.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from datetime import datetime
from typing import (
    TYPE_CHECKING,
    AsyncIterable,
    AsyncIterator,
    Dict,
    Iterable,
    List,
    Optional,
    Union,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


@dataclass(eq=False, repr=False)
class BlobMetadata(betterproto.Message):
    """Metadata about the blob."""

    created_time: datetime = betterproto.message_field(1)
    """timestamp of when blob was created"""

    retention_time: datetime = betterproto.message_field(2)
    """timestamp of when this blob will be retained until."""

    size_bytes: int = betterproto.uint64_field(3)
    """size of the blob contents in bytes"""

    md5: bytes = betterproto.bytes_field(4)
    """md5 sum/hash of blob contents"""

    content_type: str = betterproto.string_field(5)
    """MIME type of blob contents"""

    provenance: "BlobProvenance" = betterproto.message_field(6)
    """details regarding the blob's origin - aka source and type"""


@dataclass(eq=False, repr=False)
class BlobProvenance(betterproto.Message):
    integration_name: str = betterproto.string_field(1)
    """registered integration_name producing the Blob."""

    data_type: str = betterproto.string_field(2)
    """data type defines what is inside of the Blob. Must be registered."""


@dataclass(eq=False, repr=False)
class CreateBlobRequest(betterproto.Message):
    """Create and store a new blob (<=2MB)."""

    client_id: str = betterproto.string_field(1)
    """blobs created will be namespaced by client_id"""

    key: str = betterproto.string_field(2)
    """unique (per client) key for the blob"""

    retention_time: datetime = betterproto.message_field(3)
    """
    timestamp after which should no longer retain this blob. required and
    cannot be > 90 days in the future.
    """

    md5: bytes = betterproto.bytes_field(4)
    """
    optional md5 sum/hash of contents. if provided, will be validated against
    md5 of contents
    """

    contents: bytes = betterproto.bytes_field(5)
    """
    contents of the entire blob, maximum size is 2MB (2 * 1024 * 1024 bytes)
    """

    provenance: "BlobProvenance" = betterproto.message_field(6)
    """details regarding the blob's origin - aka source and type"""


@dataclass(eq=False, repr=False)
class CreateBlobResponse(betterproto.Message):
    metadata: "BlobMetadata" = betterproto.message_field(1)
    url: str = betterproto.string_field(2)
    """URL at which the blob can be fetched"""


@dataclass(eq=False, repr=False)
class CreateBlobChunkedRequest(betterproto.Message):
    """
    Create and store a new blob. Only the first 'CreateBlobChunkedRequest'
    message in the client stream needs to contain metadata specific fields (IE:
    client_id, key, md5 etc.). Metadata fields set on all requests ensuing the
    first request will be ignored.
    """

    client_id: str = betterproto.string_field(1)
    """blobs created will be namespaced by client_id"""

    key: str = betterproto.string_field(2)
    """unique (per client) key for the blob"""

    retention_time: datetime = betterproto.message_field(3)
    """
    timestamp after which should no longer retain this blob. required and
    cannot be > 90 days in the future.
    """

    md5: bytes = betterproto.bytes_field(4)
    """
    optional md5 sum/hash of contents. if provided, will be validated against
    the md5 of all contents in aggregate
    """

    chunk_contents: bytes = betterproto.bytes_field(5)
    """
    contents of the blob chunk, maximum size is 2MB per message (2 * 1024 *
    1024 bytes)
    """

    provenance: "BlobProvenance" = betterproto.message_field(6)
    """details regarding the blob's origin - aka source and type"""


@dataclass(eq=False, repr=False)
class CreateBlobChunkedResponse(betterproto.Message):
    metadata: "BlobMetadata" = betterproto.message_field(1)
    url: str = betterproto.string_field(2)
    """URL at which the blob can be fetched"""


@dataclass(eq=False, repr=False)
class GetBlobRequest(betterproto.Message):
    client_id: str = betterproto.string_field(1)
    key: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class GetBlobResponse(betterproto.Message):
    contents: bytes = betterproto.bytes_field(1)
    """
    contents of the blob, maximum size of each response message contents in
    stream is capped at 2MB.
    """

    metadata: "BlobMetadata" = betterproto.message_field(2)
    """metadata will only be present in the first stream message"""


@dataclass(eq=False, repr=False)
class HeadBlobRequest(betterproto.Message):
    client_id: str = betterproto.string_field(1)
    key: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class HeadBlobResponse(betterproto.Message):
    metadata: "BlobMetadata" = betterproto.message_field(1)
    url: str = betterproto.string_field(2)
    """URL at which the blob can be fetched"""


@dataclass(eq=False, repr=False)
class StreamBlobMetadataRequest(betterproto.Message):
    client_id: str = betterproto.string_field(1)
    """The blob client_id to stream."""


@dataclass(eq=False, repr=False)
class StreamBlobMetadataResponse(betterproto.Message):
    announcements: List["BlobAnnouncement"] = betterproto.message_field(1)
    """
    The set of blob announcement metadata returned from a
    StreamBlobMetadataResponse.
    """


@dataclass(eq=False, repr=False)
class BlobAnnouncement(betterproto.Message):
    client_id: str = betterproto.string_field(1)
    """The announced blob's specific client-driven namespace."""

    key: str = betterproto.string_field(2)
    """The announced blob's unique key."""

    metadata: "BlobMetadata" = betterproto.message_field(3)
    """The metadata describing the blob's contents."""


@dataclass(eq=False, repr=False)
class Statement(betterproto.Message):
    """
    If match and not_match are both populated, both must evaluate to true for
    Statement to evaluate to true. If match is not populated, only not_match is
    used. If not_match is empty, only match is used. If match is not populated
    and not_match is empty, Statement evaluates to true.
    """

    match: "FieldMatcher" = betterproto.message_field(1)
    """Positive match fields."""

    not_match: List["FieldMatcher"] = betterproto.message_field(2)
    """
    Negative match fields. All not_match FieldMatchers must evaluate to false
    for this to evaluate to true.
    """


@dataclass(eq=False, repr=False)
class FieldMatcher(betterproto.Message):
    """All populated fields must be an exact match (logical AND)."""

    integration_name: str = betterproto.string_field(1)
    mime_type: str = betterproto.string_field(2)
    data_type: str = betterproto.string_field(3)


class BlobsApiStub(betterproto.ServiceStub):
    async def create_blob(
        self,
        create_blob_request: "CreateBlobRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "CreateBlobResponse":
        return await self._unary_unary(
            "/anduril.blobs.v1.BlobsAPI/CreateBlob",
            create_blob_request,
            CreateBlobResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def create_blob_chunked(
        self,
        create_blob_chunked_request_iterator: Union[
            AsyncIterable["CreateBlobChunkedRequest"],
            Iterable["CreateBlobChunkedRequest"],
        ],
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "CreateBlobChunkedResponse":
        return await self._stream_unary(
            "/anduril.blobs.v1.BlobsAPI/CreateBlobChunked",
            create_blob_chunked_request_iterator,
            CreateBlobChunkedRequest,
            CreateBlobChunkedResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_blob(
        self,
        get_blob_request: "GetBlobRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["GetBlobResponse"]:
        async for response in self._unary_stream(
            "/anduril.blobs.v1.BlobsAPI/GetBlob",
            get_blob_request,
            GetBlobResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def head_blob(
        self,
        head_blob_request: "HeadBlobRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "HeadBlobResponse":
        return await self._unary_unary(
            "/anduril.blobs.v1.BlobsAPI/HeadBlob",
            head_blob_request,
            HeadBlobResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def stream_blob_metadata(
        self,
        stream_blob_metadata_request: "StreamBlobMetadataRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["StreamBlobMetadataResponse"]:
        async for response in self._unary_stream(
            "/anduril.blobs.v1.BlobsAPI/StreamBlobMetadata",
            stream_blob_metadata_request,
            StreamBlobMetadataResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class BlobsApiBase(ServiceBase):

    async def create_blob(
        self, create_blob_request: "CreateBlobRequest"
    ) -> "CreateBlobResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def create_blob_chunked(
        self,
        create_blob_chunked_request_iterator: AsyncIterator["CreateBlobChunkedRequest"],
    ) -> "CreateBlobChunkedResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_blob(
        self, get_blob_request: "GetBlobRequest"
    ) -> AsyncIterator["GetBlobResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield GetBlobResponse()

    async def head_blob(
        self, head_blob_request: "HeadBlobRequest"
    ) -> "HeadBlobResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def stream_blob_metadata(
        self, stream_blob_metadata_request: "StreamBlobMetadataRequest"
    ) -> AsyncIterator["StreamBlobMetadataResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield StreamBlobMetadataResponse()

    async def __rpc_create_blob(
        self, stream: "grpclib.server.Stream[CreateBlobRequest, CreateBlobResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.create_blob(request)
        await stream.send_message(response)

    async def __rpc_create_blob_chunked(
        self,
        stream: "grpclib.server.Stream[CreateBlobChunkedRequest, CreateBlobChunkedResponse]",
    ) -> None:
        request = stream.__aiter__()
        response = await self.create_blob_chunked(request)
        await stream.send_message(response)

    async def __rpc_get_blob(
        self, stream: "grpclib.server.Stream[GetBlobRequest, GetBlobResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_blob,
            stream,
            request,
        )

    async def __rpc_head_blob(
        self, stream: "grpclib.server.Stream[HeadBlobRequest, HeadBlobResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.head_blob(request)
        await stream.send_message(response)

    async def __rpc_stream_blob_metadata(
        self,
        stream: "grpclib.server.Stream[StreamBlobMetadataRequest, StreamBlobMetadataResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.stream_blob_metadata,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/anduril.blobs.v1.BlobsAPI/CreateBlob": grpclib.const.Handler(
                self.__rpc_create_blob,
                grpclib.const.Cardinality.UNARY_UNARY,
                CreateBlobRequest,
                CreateBlobResponse,
            ),
            "/anduril.blobs.v1.BlobsAPI/CreateBlobChunked": grpclib.const.Handler(
                self.__rpc_create_blob_chunked,
                grpclib.const.Cardinality.STREAM_UNARY,
                CreateBlobChunkedRequest,
                CreateBlobChunkedResponse,
            ),
            "/anduril.blobs.v1.BlobsAPI/GetBlob": grpclib.const.Handler(
                self.__rpc_get_blob,
                grpclib.const.Cardinality.UNARY_STREAM,
                GetBlobRequest,
                GetBlobResponse,
            ),
            "/anduril.blobs.v1.BlobsAPI/HeadBlob": grpclib.const.Handler(
                self.__rpc_head_blob,
                grpclib.const.Cardinality.UNARY_UNARY,
                HeadBlobRequest,
                HeadBlobResponse,
            ),
            "/anduril.blobs.v1.BlobsAPI/StreamBlobMetadata": grpclib.const.Handler(
                self.__rpc_stream_blob_metadata,
                grpclib.const.Cardinality.UNARY_STREAM,
                StreamBlobMetadataRequest,
                StreamBlobMetadataResponse,
            ),
        }
