# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: anduril/entityhistory/v1/entity_history_api.pub.proto, anduril/entityhistory/v1/history.pub.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from datetime import datetime
from typing import (
    TYPE_CHECKING,
    Dict,
    List,
    Optional,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from ...entitymanager import v1 as __entitymanager_v1__


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class HistoryType(betterproto.Enum):
    HISTORY_TYPE_INVALID = 0
    HISTORY_TYPE_TRAIL = 1
    HISTORY_TYPE_SNAPSHOT = 2
    HISTORY_TYPE_COMPOSITE = 3


class StorageSystem(betterproto.Enum):
    STORAGE_SYSTEM_INVALID = 0
    STORAGE_SYSTEM_PERSISTENT = 1
    STORAGE_SYSTEM_EPHEMERAL = 2


@dataclass(eq=False, repr=False)
class HistoryPage(betterproto.Message):
    """
    Pages of requested history. One page is returned for each Query. If the
    returned data can not all fit into one grpc response, a NextPageToken will
    be returned. The page returned corresponds to the requested type of history
    in the HistoryQuery.
    """

    trail_page: "TrailPage" = betterproto.message_field(1, group="type")
    snapshot_page: "SnapshotPage" = betterproto.message_field(2, group="type")
    composite_page: "CompositePage" = betterproto.message_field(3, group="type")


@dataclass(eq=False, repr=False)
class SnapshotPage(betterproto.Message):
    """A page of snapshots."""

    snapshots: List["Snapshot"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class TrailPage(betterproto.Message):
    """A page of trails."""

    trails: List["Trail"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class CompositePage(betterproto.Message):
    """A page of composited history."""

    snapshots: List["Snapshot"] = betterproto.message_field(1)
    trails: List["Trail"] = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class Snapshot(betterproto.Message):
    """
    A snapshot is a summarized history for a given entity. It consists of the
    origin state for the entity, its current state, and snapshot events which
    represent major changes to the entity over its lifespan.
    """

    latest_state: "__entitymanager_v1__.Entity" = betterproto.message_field(1)
    """The latest state for a given entity."""

    original_state: "__entitymanager_v1__.Entity" = betterproto.message_field(2)
    """The first observed state of the entity."""

    snapshot_events: List["SnapshotEvent"] = betterproto.message_field(3)
    """A set of events corresponding to significant changes in this entity."""


@dataclass(eq=False, repr=False)
class SnapshotEvent(betterproto.Message):
    """A snapshot event represents any significant change to the entity."""

    timestamp: datetime = betterproto.message_field(1)
    entity_change_event: "EntityChangeEvent" = betterproto.message_field(
        2, group="type"
    )
    entity_state: "__entitymanager_v1__.EntityEvent" = betterproto.message_field(
        3, group="type"
    )


@dataclass(eq=False, repr=False)
class EntityChangeEvent(betterproto.Message):
    """
    An entity change is encoded as a timestamp and two partial entity states
    representing the fields that changed on the entity. For example: From:
    Entity: { MilView: { Disposition: Neutral } }. To: Entity: { MilView: {
    Disposition: Suspicious } }. Clients can determine the updated fields by
    examining the entity partials included in from & to.
    """

    from_: "__entitymanager_v1__.Entity" = betterproto.message_field(1)
    """A partial of an entity state containing the old field(s)."""

    to: "__entitymanager_v1__.Entity" = betterproto.message_field(2)
    """A partial of an entity state containing the changed field(s)."""


@dataclass(eq=False, repr=False)
class Trail(betterproto.Message):
    """A trail represents the historical positions of a given entity."""

    entity_id: str = betterproto.string_field(1)
    """The GUID of the trail's parent entity."""

    trail_points: List["TrailPoint"] = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class TrailPoint(betterproto.Message):
    """
    A trail point consists of a timestamp, location, and uncertainty. The above
    information preserves kinematics, precise position, and uncertainty for all
    reported points.
    """

    timestamp: datetime = betterproto.message_field(1)
    location: "__entitymanager_v1__.Location" = betterproto.message_field(2)
    location_uncertainty: "__entitymanager_v1__.LocationUncertainty" = (
        betterproto.message_field(3)
    )


@dataclass(eq=False, repr=False)
class HistoryPageToken(betterproto.Message):
    """
    Query page token key used for EntityHistory and enables paginated query
    responses. Clients should not modify values and only provide the key back
    to the server if is_complete is false.
    """

    query_id: str = betterproto.string_field(1)
    page_num: int = betterproto.int32_field(2)
    entity_id: str = betterproto.string_field(3)
    storage_system: "StorageSystem" = betterproto.enum_field(4)
    start_time: str = betterproto.string_field(5)
    """Query start time for the current entity in ISO-8601 format."""

    is_complete: bool = betterproto.bool_field(6)
    """
    True if the query is complete, false if another request beginning with this
    key should be sent to consume more data.
    """


@dataclass(eq=False, repr=False)
class ListHistoryRequest(betterproto.Message):
    history_query: "HistoryQuery" = betterproto.message_field(1)
    """Specifies the history returned to the client."""

    page_token: str = betterproto.string_field(2)
    """
    Page token in the case that the query results are paginated. This will be
    deprecated in favor of history_page_token.
    """

    history_page_token: "HistoryPageToken" = betterproto.message_field(3)
    """
    history_page_token should be provided as part of a request to consume
    paginated history data and was received via the most recent
    ListHistoryResponse. Clients should not create this on their own and the
    initial ListHistoryRequest should leave this field empty.
    """


@dataclass(eq=False, repr=False)
class ListHistoryResponse(betterproto.Message):
    history_page: "HistoryPage" = betterproto.message_field(1)
    next_page_token: str = betterproto.string_field(2)
    """
    If present this page token can be used to retrieve the next page of
    history. If empty, there are no more results. This will be deprecated in
    favor of next_history_page_token.
    """

    next_history_page_token: "HistoryPageToken" = betterproto.message_field(3)
    """
    Next_history_page_token received should be provided as part of any followup
    requests to continue consuming the data for the query requested until the
    HistoryPageToken reports is_complete as true.
    """


@dataclass(eq=False, repr=False)
class HistoryQuery(betterproto.Message):
    """
    A query for entity history. Required fields are history type and time
    range. Downsampling and additional filter parameters are optional. If no
    additional filter is specified, all entity historical data of the specified
    type is returned for the provided time range.
    """

    history_type: "HistoryType" = betterproto.enum_field(1)
    """The type of history to query."""

    time_range: "TimeRange" = betterproto.message_field(2)
    """
    Time range for the below queries. If no query is specified, all data for
    the history type during the time range is returned.
    """

    downsample: "Downsample" = betterproto.message_field(3)
    """
    Downsampling to apply to a time ordered set of points. May not apply to all
    history data types. Currently supported types are: trails.
    """

    statement: "__entitymanager_v1__.Statement" = betterproto.message_field(4)
    """
    Filter for historical data. The applied filter limits the data returned by
    the query to only the data with matching current entity state. The filter
    is applied to the latest observed state recorded in a snapshot. Live state
    is not considered.
    """

    entity_ids: List[str] = betterproto.string_field(5)
    """
    Set of entityIds to request history data for. If empty, all entityIds will
    be found by querying TimeSeries.
    """


@dataclass(eq=False, repr=False)
class TimeRange(betterproto.Message):
    """
    Range of wall-clock time. If upper bound timestamp is greater than the
    current time, the query will truncate the future time to now and return any
    history between lower bound and now. If both of the bounds are in the
    future, the query will report no available historical data.
    """

    lower_bound_inc: datetime = betterproto.message_field(1)
    """Earliest time in the TimeRange."""

    upper_bound_exc: datetime = betterproto.message_field(2)
    """Latest time in the TimeRange."""


@dataclass(eq=False, repr=False)
class Downsample(betterproto.Message):
    """
    Downsampling is applied to points in an individual historical data model.
    Enforces each point is separated by at least downsample_duration millis.
    For example: downsample_duration = 10,000. stored points = [ 0, 5,000,
    10,000, 13,000, 22,000, 30,000, 35,000 ]. returned points = [ 0, 10,000,
    22,000, 35,000 ].
    """

    downsample_duration: "DownsampleDuration" = betterproto.message_field(
        1, group="type"
    )


@dataclass(eq=False, repr=False)
class DownsampleDuration(betterproto.Message):
    duration_ms: int = betterproto.uint32_field(1)
    """Downsample duration specified in milliseconds."""


@dataclass(eq=False, repr=False)
class StreamBackfillUpdatesRequest(betterproto.Message):
    """
    Open a server stream to receive updates to entity time windows after Entity
    History has processed a backfill event or healing job. The stream is long-
    lived and only delivers new updates as they arrive.
    """

    pass


@dataclass(eq=False, repr=False)
class StreamBackfillUpdatesResponse(betterproto.Message):
    backfill_updates: List["BackfillUpdate"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class BackfillUpdate(betterproto.Message):
    """
    Indicates the entity identified by entity_id has new data available in
    EntityHistory for the time period described by time_range.
    """

    entity_id: str = betterproto.string_field(1)
    time_range: "TimeRange" = betterproto.message_field(2)


class EntityHistoryApiStub(betterproto.ServiceStub):
    async def list_history(
        self,
        list_history_request: "ListHistoryRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ListHistoryResponse":
        return await self._unary_unary(
            "/anduril.entityhistory.v1.EntityHistoryAPI/ListHistory",
            list_history_request,
            ListHistoryResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class EntityHistoryApiBase(ServiceBase):

    async def list_history(
        self, list_history_request: "ListHistoryRequest"
    ) -> "ListHistoryResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_list_history(
        self, stream: "grpclib.server.Stream[ListHistoryRequest, ListHistoryResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.list_history(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/anduril.entityhistory.v1.EntityHistoryAPI/ListHistory": grpclib.const.Handler(
                self.__rpc_list_history,
                grpclib.const.Cardinality.UNARY_UNARY,
                ListHistoryRequest,
                ListHistoryResponse,
            ),
        }
